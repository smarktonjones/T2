<!DOCTYPE html>
<!-- version as of 05NOV2025 mgh -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dental Note - MAKER</title>
    <style>
        :root {
            --bg-color: #f0f2f5; --main-bg: #ffffff; --section-bg: #f9f9f9;
            --section-border: #d9d9d9; --element-bg: #e6f7ff; --element-border: #91d5ff;
            --element-shadow: 0 2px 4px rgba(0,0,0,0.1); --button-bg: #1890ff;
            --button-text: #ffffff; --button-hover-bg: #40a9ff; --text-color: #333;
            --modal-bg: rgba(0,0,0,0.5); --danger-color: #d93025;
            --warning-color: #fd7e14; --success-color: #28a745; --success-hover: #218838;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background-color: #f0f2f5; 
 background-image: linear-gradient(to bottom, #fafafa, #e8e8e8); /* The gradient */
 color: var(--text-color); margin: 0; padding: 20px; }
        h1 { font-size: 48px; text-align: left; margin-top: 0; text-shadow: 5px 5px 8px rgba(0, 0, 0, 0.5);}
h2 { text-align: center; margin-top: 0; color: var(--danger-color); font-weight: bold; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);}
h5 { text-align: center; margin-top: 0; font-weight: light;}    
        .layout-container, .main-body-container { display: flex; flex-direction: column; gap: 15px; }
        .section-container { background-color: var(--main-bg); border: 2px dashed var(--section-border); border-radius: 8px; padding: 15px; display: flex; flex-direction: column; }
        .section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--section-border); }
        .add-element-btn { background-color: var(--button-bg); color: var(--button-text); border: none; border-radius: 50%; width: 30px; height: 30px; font-size: 20px; font-weight: bold; cursor: pointer; line-height: 30px; text-align: center; }
        
        .dropzone { flex-grow: 1; display: flex; flex-wrap: wrap; align-items: center; gap: 10px; min-height: 50px; }
        .draggable-element { background-color: var(--element-bg); border: 2px solid var(--element-border); border-radius: 4px; cursor: grab; box-shadow: var(--element-shadow); resize: both; overflow: auto; min-width: 180px; min-height: 50px; padding: 10px; display: flex; flex-direction: column; gap: 8px;  }
        body.layout-locked .draggable-element {cursor: default;}

        /* Styles for Hidden Elements and highlighted */
.element-highlighted {border-color: var(--success-color) !important; }
        .element-hidden { display: none; }
        body.show-hidden-elements .element-hidden { display: flex; border-style: dotted; border-color: var(--danger-color); }
        
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: var(--modal-bg); overflow: auto; }
        .modal-content { background-color: #fff; margin: 5% auto; padding: 20px; border: 1px solid #888; width: 90%; max-width: 900px; border-radius: 8px; display: flex; flex-direction: column; max-height: 85vh; }
        .modal-body { flex-grow: 1; overflow: auto; position: relative; } .modal-footer { margin-top: 20px; flex-shrink: 0; display:flex; justify-content:flex-end; gap: 10px;}
        
        #context-menu { display: none; position: absolute; z-index: 2000; background-color: var(--main-bg); border-radius: 4px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 5px 0; min-width: 150px; }
        #properties-body { padding: 10px 0; } #properties-body fieldset { border: 1px solid #ccc; border-radius: 4px; padding: 10px; margin-bottom: 10px; }
        .copy-btn-prominent { background-color: var(--success-color); font-size: 18px; padding: 12px 24px; font-weight: bold; }
        .copy-btn-prominent:hover { background-color: var(--success-hover); }
        #reset-btn { background-color: var(--danger-color); font-size: 18px; padding: 12px 24px; font-weight: bold; }
        .controls { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 20px; align-items: center; }
        /* All other element-specific styles are here */
        .endo-testing-element, .anesthetic-element, .enhanced-textbox, .alert-element { cursor: pointer; justify-content: center; }
        .internal-label { font-size: 0.8em; font-weight: bold; color: #0050b3; margin-bottom: 4px; }
        .enhanced-textbox-preview { font-style: italic; color: #555; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .alert-element { padding: 10px; text-align: center; font-weight: bold; color: var(--button-text); resize: none; min-height: initial; }
        .alert-blank { background-color: var(--warning-color); border-color: var(--warning-color)!important; }
        .alert-none { background-color: var(--success-color); border-color: var(--success-color)!important; }
        .alert-active { background-color: var(--danger-color); border-color: var(--danger-color)!important; }
        .bp-element input[type="number"] { width: 45px; text-align: center; }
        .bp-prior-tx-container { display: none; } .bp-prior-tx-container.visible { display: block; }
        
/* **** START OF MODIFIED CSS to take precedence over other colors **** */
.bp-normal { border-color: var(--bp-normal) !important; } 
.bp-elevated { border-color: #ffc107 !important; } 
.bp-stage1 { border-color: var(--warning-color) !important; } 
.bp-stage2 { border-color: var(--danger-color) !important; } 
.bp-crisis { border-color: #8b0000 !important; animation: pulse 1.5s infinite; }
/* **** END OF MODIFIED CSS **** */
   
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 var(--bp-crisis); } 70% { box-shadow: 0 0 5px 8px transparent; } 100% { box-shadow: 0 0 0 0 transparent; } }
        .psr-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; font-family: monospace; }
        .psr-sextant { text-align: center; } .psr-sextant label { font-size: 0.8em; color: #555; display: block; }
        .psr-grid input[type="text"] { width: 100%; box-sizing: border-box; text-align: center; }
        .psr-asterisk-note { display: none; width: 100%; } .psr-asterisk-note.visible { display: block; margin-top: 5px; }
        .pain-scale-container { display: flex; align-items: center; gap: 10px; }
        .pain-scale-container input[type=range] { flex-grow: 1; }
        #textbox-editor-area { display: flex; flex-direction: column; gap: 10px; align-items: stretch; height: 100%; }
        #textbox-editor-textarea { flex-grow: 1; min-height: 200px; resize: vertical; position: relative;}
        #textbox-editor-snippets { display: flex; align-items: center; gap: 10px; }
        #textbox-editor-select { flex-grow: 1; }
        #textbox-editor-buttons { display: flex; flex-direction: column; gap: 5px; }
        #anesthetic-editor-list .anesthetic-row, #prop-anesthetic-types .prop-anesthetic-row { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; margin-bottom: 10px; }
        #prop-anesthetic-types .prop-anesthetic-row { grid-template-columns: 2fr 1fr 1fr auto; }
        #prop-anesthetic-types .prop-anesthetic-row input { width: 100%; box-sizing: border-box; }
        .remove-btn { color: var(--danger-color); cursor: pointer; font-weight: bold; }
        #endo-table { border-collapse: collapse; width: 100%; }
        #endo-table th, #endo-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        #endo-table input { width: 100%; box-sizing: border-box; border: none; background: transparent; }
        #endo-editor-controls { display: flex; gap: 10px; padding: 10px 0; align-items: center; }


        /* **** START OF NEW CSS **** */

        /* Style for the "Priority Level" text */
        #tx-plan-table .priority-label {
            font-size: 0.8em;
            color: #555;
            display: block;
        }

        /* Style the row-header cells (Oral Hygiene, etc.) */
        #tx-plan-table .tx-row-header {
            background-color: #f2f2f2; /* Light gray background */
            color: #0050b3;          /* Bold blue text */
            font-weight: bold;
        }

        /* Style the textarea for a different default color */
        #tx-plan-table textarea {
            background-color: #f8f9fa; /* A very light gray */
            border: 1px solid #ced4da;
            border-radius: 4px;
            padding: 5px;
            transition: background-color 0.2s, border-color 0.2s; /* Smooth transition */
        }
        
        /* Style the textarea when it has content */
        #tx-plan-table textarea.has-content {
            background-color: #fff;
            border-color: var(--success-color); /* Green border */
            outline: 2px solid transparent; /* Prevents default focus outline from clashing */
        }

        /* **** END OF NEW CSS **** */

           /* **** START OF NEW CODE for tx plan copy/paste **** */
        #text-selection-menu .selection-menu-item {
            padding: 8px 16px;
            cursor: pointer;
        }
        #text-selection-menu .selection-menu-item:hover {
            background-color: var(--button-bg);
            color: var(--button-text);
        }
        #action-feedback.success { background-color: var(--success-color); }
        #action-feedback.error { background-color: var(--danger-color); }
        /* **** END OF NEW CODE **** */


        /* **** logo CODE **** */
    .logo {
      position: relative;
      width: 450px;
      height: 300px;
    }


.logo-container {
position: absolute;
left: 0;
transform: translateY(-55%) translateX(20%) scale(0.25, 0.3);
transform-origin: left bottom;
z-index: -1;
opacity: 0.4;
}

    .quarter {
      position: absolute;
      width: 210px;
      height: 140px;
      border-top-left-radius: 210px 140px;
      overflow: hidden;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
    }

    .quarter::after {
      content: "";
      position: absolute;
      top: 10%;
      left: 10%;
      width: 80%;
      height: 80%;
      background: radial-gradient(ellipse at top left, rgba(255, 255, 255, 0.5), transparent 60%);
      border-top-left-radius: 210px 140px;
    }

    .navy {
      background: linear-gradient(135deg, lightgray, white);
      top: 0;
      left: 0;
    }

    .yellow {
      background: linear-gradient(135deg, white, lightgray);
      bottom: 0;
      right: 0;
      transform: rotate(180deg);
    }

    .center {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 60px;
      height: 60px;
      margin: -30px 0 0 -30px;
      background: linear-gradient(145deg, white, lightgray);
      border-radius: 50%;
      box-shadow:
        inset 0 5px 10px rgba(255, 255, 255, 0.5),
        0 4px 10px rgba(0, 0, 0, 0.3);
    }

    .center::after {
      content: "";
      position: absolute;
      top: 10%;
      left: 10%;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at top left, rgba(255, 255, 255, 0.6), transparent 70%);
      border-radius: 50%;
    }

    .text-top-right,
    .text-bottom-left {
      position: absolute;
      width: 210px;
      height: 140px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 60px;
      padding: 10px;
      text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.6),
                   -1px -1px 2px rgba(0, 0, 0, 0.2);
    }

    /* Upper Right Text - Dental Note */
    .text-top-right {
      top: 0;
      right: 0;
      color: lightgray; /* blue */
      font-weight: 700; /* bold */
      justify-content: flex-end; /* right-align text within quadrant */
      text-align: right;
      line-height: .7;
      padding-right: 40px;
      padding-top: 30px;
    }

    /* Lower Left Text - Maker */
    .text-bottom-left {
      bottom: 0;
      left: 0;
      color: lightgray;
      font-weight: 100; /* thin font */
      font-style: normal;
      justify-content: flex-start;
      text-align: right;
      line-height: .7;
      padding-left: 20px;
      padding-bottom: 20px;
    }

        /* **** END OF LOGO CODE **** */

        /* **** style for charting CODE **** */
        .container {
            max-width: 850px; /* Wider to accommodate labels */
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        .chart-output {
            margin-top: 30px;
            border-top: 1px solid #eee;
            padding-top: 20px;
            text-align: center;
        }
        /* SVG Styles */
        svg {
            border: 1px solid #eee;
            background-color: #fcfcfc;
            width: 100%;
            max-width: 800px; /* Match container width for consistency */
            height: auto;
            display: block;
            margin: 20px auto;
        }
        .tooth-outline {
            fill: #e0e0e0;
            stroke: #999;
            stroke-width: 1;
        }
        .tooth-surface {
            fill: #f0f0f0; /* Default surface color, slightly lighter */
            stroke: #bbb;
            stroke-width: 0.5;
        }
        .caries {
            fill: red !important; /* Mark caries in red */
        }
        .tooth-label {
            font-size: 7px; /* Labels for tooth numbers */
            text-anchor: middle;
            fill: #333;
            font-weight: bold;
        }
        .arch-line {
            stroke: #aaa;
            stroke-width: 2;
            fill: none;
        }
        .mouth-label {
            font-size: 10px;
            font-weight: bold;
            fill: #555;
            text-anchor: middle;
        }
        .label-line {
            stroke: #ccc;
            stroke-width: 1;
            stroke-dasharray: 3 3;
        }



   
    </style>
</head>
<body>





<div class="logo-container" >
  <div class="logo">
    <!-- Stretched Shapes -->
    <div class="quarter navy"></div>
    <div class="quarter yellow"></div>

    <!-- Center Circle -->
    <div class="center"></div>

    <!-- Text Labels -->
    <div class="text-top-right">Dental Note</div>
    <div class="text-bottom-left">Maker v2.11</div>
  </div>

</div>

    <h1>ORAL EXAM</h1>

    <div style="text-align: center; margin-bottom: 10px;"><button id="copy-btn-top" class="control-btn copy-btn-prominent">Copy Note to Clipboard (Shift+ Enter)</button></div>
    <!-- Layout and Modals -->
    <div class="layout-container"><div id="header-section" class="section-container"><div class="section-header"><h2>--</h2><button class="add-element-btn" data-section="header-section">+</button></div><div class="dropzone" data-section-id="header"></div></div><div class="main-body-container"><div id="subjective-section" class="section-container"><div class="section-header"><h2>S: SUBJECTIVE FINDINGS</h2><button class="add-element-btn" data-section="subjective-section">+</button></div><div class="dropzone" data-section-id="subjective"></div></div><div id="objective-section" class="section-container"><div class="section-header"><h2>O: OBJECTIVE FINDINGS</h2><button class="add-element-btn" data-section="objective-section">+</button></div><div class="dropzone" data-section-id="objective"></div></div><div id="assessment-section" class="section-container"><div class="section-header"><h2>A: ASSESSMENT OF FINDINGS & CHIEF COMPLAINT</h2><button class="add-element-btn" data-section="assessment-section">+</button></div><div class="dropzone" data-section-id="assessment"></div></div><div id="plan-section" class="section-container"><div class="section-header"><h2>P: TREATMENT PLAN</h2><button class="add-element-btn" data-section="plan-section">+</button></div><div class="dropzone" data-section-id="plan"></div></div></div><div id="footer-section" class="section-container"><div class="section-header"><h2>--</h2><button class="add-element-btn" data-section="footer-section">+</button></div><div class="dropzone" data-section-id="footer"></div></div></div>
    <div class="controls">
        <button id="import-btn" class="control-btn">Import JSON File...</button>
        <button id="export-btn" class="control-btn">Export JSON</button>
        <label style="display:flex; align-items:center; gap: 5px;"><input type="checkbox" id="view-hidden-toggle"> View Hidden Elements</label>
<label style="display:flex; align-items:center; gap: 5px;"><input type="checkbox" id="lock-layout-toggle" checked> Lock Layout</label>
        <button id="reset-btn" class="control-btn">Reset Values</button>
<button id="full-reset-btn" class="control-btn" style="background-color: var(--warning-color);">Full Reset</button>
    </div>
    <div class="output-container" style="margin-top: 20px;"><h2>Live Note Preview</h2><textarea id="live-output" style="width: 100%; box-sizing: border-box; height: 200px; font-family: monospace; white-space: pre-wrap;"></textarea>

        <div class="chart-output">
            <h2>Caries Charting</h2> <h5>From Treatment Plan element - (duplicate in Dentrix)</h5>
            <svg id="dentalChart" viewBox="0 0 850 400" preserveAspectRatio="xMidYMid meet"></svg>
        </div>



<button id="copy-btn-bottom" class="control-btn copy-btn-prominent" style="margin-top: 10px;">Copy Note to Clipboard (Shift+ Enter)</button></div>
    <div id="add-element-modal" class="modal"><div class="modal-content"><div class="modal-header"><h2>Add New Element</h2><span class="close-btn" data-modal-id="add-element-modal">&times;</span></div><div class="modal-body element-type-list" style="display: flex; flex-direction: column; gap: 10px;">

           <div class="element-type" data-type="tx-plan"><h3>Treatment Plan</h3></div>
   
   <div class="element-type" data-type="endo-testing"><h3>Endo Testing Table</h3></div><div class="element-type" data-type="anesthetic"><h3>Anesthetic Calculator</h3></div><div class="element-type" data-type="enhanced-textbox"><h3>Pop-up Text Box</h3></div><div class="element-type" data-type="alert"><h3>Allergy/Alert Selector</h3></div><div class="element-type" data-type="painscale"><h3>Pain Scale</h3></div><div class="element-type" data-type="bloodpressure"><h3>Blood Pressure</h3></div><div class="element-type" data-type="psr"><h3>PSR</h3></div><hr><div class="element-type" data-type="dropdown"><h3>Simple Dropdown</h3></div><div class="element-type" data-type="checkbox"><h3>Checkbox</h3></div><div class="element-type" data-type="formatter"><h3>Formatter</h3></div><hr><div class="element-type" data-type="label-red"><h3>Red Label</h3></div><div class="element-type" data-type="label-black"><h3>Black Label</h3></div></div></div></div>
    <div id="properties-modal" class="modal"><div class="modal-content"><div class="modal-header"><h2 id="properties-title">Edit Properties</h2><span class="close-btn" data-modal-id="properties-modal">&times;</span></div><div class="modal-body" id="properties-body"></div><div class="modal-footer"><button id="properties-save-btn" class="control-btn">Save Changes</button></div></div></div>
    <div id="context-menu"><div id="ctx-properties">Properties...</div><div id="ctx-delete">Delete Element</div></div>

  

    <!-- Feedback message toast -->
    <div id="action-feedback" style="display: none; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 10px 20px; border-radius: 20px; color: white; z-index: 12000; transition: opacity 0.5s;"></div>
    <!-- **** END OF NEW CODE **** -->

    <div id="endo-testing-modal" class="modal"><div class="modal-content"><div class="modal-header"><h2>Endo Testing Results</h2><span class="close-btn" data-modal-id="endo-testing-modal">&times;</span></div><div class="modal-body"><div id="endo-editor-controls"><input type="text" id="endo-range-input" placeholder="e.g., 3-6, 14, 18-19"><button id="endo-range-add-btn" class="control-btn">Add Teeth</button></div><div style="overflow-x:auto;"><table id="endo-table"><thead></thead><tbody></tbody></table></div></div><div class="modal-footer"><button id="endo-testing-save-btn" class="control-btn">Save & Close</button></div></div></div>
    <div id="anesthetic-editor-modal" class="modal"><div class="modal-content"><div class="modal-header"><h2>Set Anesthetic Amounts</h2><span class="close-btn" data-modal-id="anesthetic-editor-modal">&times;</span></div><div class="modal-body"><div style="padding-bottom:15px; border-bottom:1px solid #eee; margin-bottom:15px;"><label><input type="checkbox" id="anesthetic-topical-check"> Include Topical Anesthetic</label></div><div id="anesthetic-editor-list"></div></div><div class="modal-footer"><button id="anesthetic-editor-save-btn" class="control-btn">Save & Close</button></div></div></div>
    <div id="allergy-modal" class="modal"><div class="modal-content"><div class="modal-header"><h2>Select Alerts</h2><span class="close-btn" data-modal-id="allergy-modal">&times;</span></div><div class="modal-body"><fieldset><legend>Common Alerts</legend><div id="allergy-list"></div></fieldset><hr><fieldset><legend>Custom Alert</legend><input type="text" id="custom-allergy-input" placeholder="e.g., Cats" style="width: 100%; box-sizing: border-box;"></fieldset></div><div class="modal-footer"><button id="allergy-save-btn" class="control-btn">Save Alerts</button></div></div></div>
    <div id="textbox-editor-modal" class="modal"><div class="modal-content"><div class="modal-header"><h2>Edit Text</h2><span class="close-btn" data-modal-id="textbox-editor-modal">&times;</span></div><div class="modal-body">
   
<!-- **** START OF MODIFIED HTML for class to tx plan **** -->
<div id="textbox-editor-area">
    <textarea id="textbox-editor-textarea"></textarea>

    <!-- NEW container for action buttons that appear on text selection -->
    <div id="selection-actions" style="display: none; margin-top: 5px; padding: 5px; background: #f0f0f0; border-radius: 4px; text-align: center;">
        <b>Send Selected Text To:</b><br>
        <button class="control-btn selection-action-btn" data-target-class="CLASS 3">Op Class 3</button>
        <button class="control-btn selection-action-btn" data-target-class="CLASS 2">Op Class 2</button>
        <button class="control-btn selection-action-btn" data-target-class="CLASS 1">Op Class 1</button>
    </div>

    <div id="textbox-editor-snippets">
        <select id="textbox-editor-select" size="10"></select>
        <div id="textbox-editor-buttons"> <!-- Added a wrapper div -->
            <button id="textbox-editor-add-btn" class="control-btn">Add</button>
            <button id="textbox-editor-replace-btn" class="control-btn">Replace</button>
        </div>
    </div>
</div>
<!-- **** END OF MODIFIED HTML **** -->
    
    </div><div class="modal-footer"><button id="textbox-editor-save-btn" class="control-btn">Save & Close (Shift+Enter)</button></div></div></div>

        <!-- **** START OF NEW CODE for tx plan**** -->
    <div id="tx-plan-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><h2>Treatment Plan</h2><span class="close-btn" data-modal-id="tx-plan-modal">×</span></div>
            <div class="modal-body">
                <table id="tx-plan-table" style="width:100%; border-collapse: collapse;">
                    <!-- Table content will be generated by JavaScript -->
                </table>
            </div>
            <div class="modal-footer">
                <button id="tx-plan-save-btn" class="control-btn">Save & Close</button>
            </div>
        </div>
    </div>
    <!-- **** END OF NEW CODE **** -->

<script type="application/json" id="default-json-data">


{
  "header": [
    {
      "type": "dropdown",
      "required": false,
      "prefixTab": false,
      "prefixNewline": false,
      "suffixNewline": true,
      "originalId": "0-0",
      "isHidden": false,
      "doNotReset": false,
      "width": "",
      "fillColor": "#d9f7be",
      "options": [
        "-OPERATIVE APPT- ",
        "-CEREC APPT- ",
        "-SICK CALL-"
      ],
      "selected": "-OPERATIVE APPT- "
    },
    {
      "type": "enhanced-textbox",
      "required": false,
      "prefixTab": false,
      "prefixNewline": false,
      "suffixNewline": true,
      "originalId": "0-1",
      "isHidden": false,
      "doNotReset": false,
      "width": "",
      "fillColor": "#d9f7be",
      "content": "",
      "internalLabel": "Tooth / Procedure",
      "prefixLabel": "",
      "defaultText": "",
      "dropdownOptions": []
    },
    {
      "type": "enhanced-textbox",
      "required": false,
      "prefixTab": false,
      "prefixNewline": true,
      "suffixNewline": true,
      "originalId": "0-2",
      "isHidden": true,
      "doNotReset": false,
      "width": "",
      "fillColor": "",
      "content": "----------------CLINICAL NOTE-------------------",
      "internalLabel": "",
      "prefixLabel": "",
      "defaultText": "Click to edit...",
      "dropdownOptions": []
    }
  ],
  "subjective": [
    {
      "type": "enhanced-textbox",
      "required": false,
      "prefixTab": false,
      "prefixNewline": false,
      "suffixNewline": false,
      "originalId": "1-0",
      "isHidden": true,
      "doNotReset": false,
      "width": "",
      "fillColor": "",
      "content": "S: PRESENTING CONCERN: ",
      "internalLabel": "",
      "prefixLabel": "",
      "defaultText": "Click to edit...",
      "dropdownOptions": []
    },
    {
      "type": "enhanced-textbox",
      "required": false,
      "prefixTab": false,
      "prefixNewline": false,
      "suffixNewline": false,
      "originalId": "1-1",
      "isHidden": false,
      "doNotReset": false,
      "width": "",
      "fillColor": "#fff7e6",
      "content": "None. ",
      "internalLabel": "CC",
      "prefixLabel": "",
      "defaultText": "Click to edit...",
      "dropdownOptions": [
        "CONSTANT THROBBING PAIN FOR X DAYS.  POINTS TO X."
      ]
    },
    {
      "type": "painscale",
      "required": false,
      "prefixTab": true,
      "prefixNewline": false,
      "suffixNewline": true,
      "originalId": "1-2",
      "isHidden": false,
      "doNotReset": false,
      "width": "",
      "fillColor": "#fff7e6",
      "value": "0"
    }
  ],
  "objective": [
    {
      "type": "enhanced-textbox",
      "required": false,
      "prefixTab": false,
      "prefixNewline": true,
      "suffixNewline": false,
      "originalId": "2-0",
      "isHidden": false,
      "doNotReset": false,
      "width": "",
      "fillColor": "",
      "content": "O/A:  ",
      "internalLabel": "",
      "prefixLabel": "",
      "defaultText": "",
      "dropdownOptions": []
    },
    {
      "type": "enhanced-textbox",
      "required": false,
      "prefixTab": false,
      "prefixNewline": false,
      "suffixNewline": true,
      "originalId": "2-1",
      "isHidden": false,
      "doNotReset": false,
      "width": "",
      "fillColor": "#e6fffb",
      "content": "",
      "internalLabel": "Diagnosis",
      "prefixLabel": "",
      "defaultText": "",
      "dropdownOptions": [
        "Caries",
        "Cavitation",
        "Fracture",
        "NSRCT complete, temp intact --> discussed options for cuspal coverage, elect endo-onlay.",
        "E/O:  TMJ NEG, LAD NEG, ASYM NEG, SWELLING NEG",
        "I/O: LARGE CLINICAL CARIES #.",
        "PULP:  ICE   WNL BUT LINGER ON # , PALP + AT # , PERC + # , OTHERWISE WNL. NO POSITIONAL SENSITIVITY ON PAIN.",
        "RAD: LARGE CARIES NEAR PULP #",
        "A:  # CARIOUS PULP EXPOSURE WITH FRANK CARIES, IRREVERSIBLE PULPITIS WITH APRP",
        "ADDP TREATMENT COMPLETE.  757 ENDODONTICS. LIGON & ROYZENBLAT. ADDP NOTES IN THE DOCUMENT CENTER"
      ]
    }
  ],
  "assessment": [],
  "plan": [
    {
      "type": "enhanced-textbox",
      "required": false,
      "prefixTab": false,
      "prefixNewline": true,
      "suffixNewline": false,
      "originalId": "4-0",
      "isHidden": true,
      "doNotReset": false,
      "width": "",
      "fillColor": "",
      "content": "P:  ",
      "internalLabel": "",
      "prefixLabel": "",
      "defaultText": "Click to edit...",
      "dropdownOptions": []
    },
    {
      "type": "anesthetic",
      "required": false,
      "prefixTab": false,
      "prefixNewline": false,
      "suffixNewline": false,
      "originalId": "4-1",
      "isHidden": false,
      "doNotReset": false,
      "width": "",
      "fillColor": "#f9f0ff",
      "anestheticTypes": [
        {
          "name": "2% Lidocaine",
          "mg": 34,
          "epi": 17
        },
        {
          "name": "4% Septocaine",
          "mg": 68,
          "epi": 17
        },
        {
          "name": "0.5% Marcaine",
          "mg": 9,
          "epi": 9
        }
      ],
      "anestheticValues": {},
      "includeTopical": false
    },
    {
      "type": "enhanced-textbox",
      "required": false,
      "prefixTab": false,
      "prefixNewline": false,
      "suffixNewline": true,
      "originalId": "4-2",
      "isHidden": false,
      "doNotReset": false,
      "width": "",
      "fillColor": "#f9f0ff",
      "content": " Isolite. ",
      "internalLabel": "Isolation",
      "prefixLabel": "",
      "defaultText": "Click to edit...",
      "dropdownOptions": [
        " Isolite. ",
        " Rubber Dam. ",
        " Cotton Roll Isolation. ",
        " Optragate."
      ]
    },
    {
      "type": "enhanced-textbox",
      "required": false,
      "prefixTab": false,
      "prefixNewline": false,
      "suffixNewline": true,
      "originalId": "4-3",
      "isHidden": false,
      "doNotReset": false,
      "width": "",
      "fillColor": "#efdbff",
      "content": "Click to edit...",
      "internalLabel": "Materials",
      "prefixLabel": "",
      "defaultText": "Click to edit...",
      "dropdownOptions": [
        "Excavate. Etch. Optibond Universal. Revolution. A2B Filtek Supreme. Occlusion. Floss. Finish. Polish. F-Varnish.",
        "Excavate. Valiant PhD. Occlusion. Floss. F-Varnish.",
        "Excavate. Conditioner. Fuji IILC A2. Finish. Polish. F-Varnish.",
        "Sectioned crown. Excavated core. Endo-onlay prep. Etch. Optibond universal. Permaflow purple orifices / undercuts.",
        "1 x (00-Cord) 1 x (0-Cord) (removed) (performed physical/visual sulcular inspection). Viscostat clear.",
        "CEREC scan/design/mill/glaze A2 LT e.max . Check interproximal contacts. HF. Panavia V5 cementation. Occlusion. Floss. Finish. BWX check.",
        "Excavate. Access MB1,DB,P, Minimal on MB2. Root ZX estimation. Pulpectomy. EDTA. Sodium Hypochlorite. Paper Points. Calcium Hydroxide. Cotton Pellets. Fuji Triage. Occlusion reduced. "
      ]
    }
  ],
  "footer": [
    {
      "type": "enhanced-textbox",
      "required": false,
      "prefixTab": false,
      "prefixNewline": true,
      "suffixNewline": true,
      "originalId": "5-0",
      "isHidden": true,
      "doNotReset": false,
      "width": "",
      "fillColor": "",
      "content": "**Next Visit**",
      "internalLabel": "",
      "prefixLabel": "",
      "defaultText": "Click to edit...",
      "dropdownOptions": []
    },
    {
      "type": "tx-plan",
      "required": false,
      "prefixTab": false,
      "prefixNewline": false,
      "suffixNewline": true,
      "originalId": "5-1",
      "isHidden": false,
      "doNotReset": false,
      "width": "",
      "fillColor": "#fff1f0",
      "txRows": [
        "Oral Hygiene",
        "Operative",
        "Perio",
        "Oral Surgery",
        "Endo",
        "Pros",
        "Other"
      ],
      "txSnippets": [
        "RDH",
        "RECALL",
        "#"
      ],
      "txData": {}
    },
    {
      "type": "enhanced-textbox",
      "required": false,
      "prefixTab": false,
      "prefixNewline": false,
      "suffixNewline": true,
      "originalId": "5-2",
      "isHidden": true,
      "doNotReset": false,
      "width": "",
      "fillColor": "",
      "content": "----------------------------------------------------",
      "internalLabel": "",
      "prefixLabel": "",
      "defaultText": "Click to edit...",
      "dropdownOptions": []
    },
    {
      "type": "alert",
      "required": false,
      "prefixTab": false,
      "prefixNewline": true,
      "suffixNewline": true,
      "originalId": "5-3",
      "isHidden": false,
      "doNotReset": false,
      "width": "",
      "fillColor": "",
      "alerts": [
        "None"
      ]
    },
    {
      "type": "enhanced-textbox",
      "required": false,
      "prefixTab": false,
      "prefixNewline": false,
      "suffixNewline": true,
      "originalId": "5-4",
      "isHidden": true,
      "doNotReset": false,
      "width": "",
      "fillColor": "",
      "content": "PT IDX2. MED REC. HQR. LEARNING ASSESS. PT INFORMED, VERBAL CONSENT & POST-OP INST.",
      "internalLabel": "",
      "prefixLabel": "",
      "defaultText": "Click to edit...",
      "dropdownOptions": [
        "PT IDX2. MED REC. HQR. LEARNING ASSESS. PT INFORMED, VERBAL CONSENT & POST-OP INST."
      ]
    },
    {
      "type": "enhanced-textbox",
      "required": false,
      "prefixTab": false,
      "prefixNewline": false,
      "suffixNewline": true,
      "originalId": "5-5",
      "isHidden": true,
      "doNotReset": false,
      "width": "",
      "fillColor": "",
      "content": "//DUP “dental_team(horning-do, stewart-dt)completed extraoral&intraoral pre-procedure verification site marking odontogram, radiograph, caries performed a time out & tooth count prior to initiating procedure above. re-verification was continuous throughout the procedure.” DHAFORM205 //DUP",
      "internalLabel": "",
      "prefixLabel": "",
      "defaultText": "Click to edit...",
      "dropdownOptions": []
    },
    {
      "type": "enhanced-textbox",
      "required": false,
      "prefixTab": false,
      "prefixNewline": true,
      "suffixNewline": false,
      "originalId": "5-6",
      "isHidden": true,
      "doNotReset": false,
      "width": "",
      "fillColor": "",
      "content": "M G HORNING DDS\n1912969445\n  .  . .   . ____ .  .    _   _    _    _  .  .  _    \n /|/ /|,/ /_/ / /  /    / / / ` /_` /_/ /|/ /_/  \n/ | /  / / \\  / /_/    /_/ /_, /_, /  / / |  / /    ",
      "internalLabel": "",
      "prefixLabel": "",
      "defaultText": "Click to edit...",
      "dropdownOptions": []
    }
  ]
}



</script>



    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- State and Constants ---
        let lastLoadedState = null, currentSectionToAdd = null, activeElementForEditor = null;
        const SECTIONS = ['header', 'subjective', 'objective', 'assessment', 'plan', 'footer'];
        const ALLERGY_LIST = ["None", "PREGNANCY", "Penicillin", "Amoxicillin", "Codeine", "Aspirin", "NSAIDs", "Sulfa Drugs", "Local Anesthetics", "Latex", "Iodine", "Erythromycin", "Tetracycline", "Metals (Nickel, etc.)", "IV Contrast Dye", "Eugenol", "Shellfish", "Cinnamon", "Peanuts", "Tree Nuts", "Soy"];
        const PSR_AUTOFOCUS_MAP = new Map([[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]]);
        const liveOutput = document.getElementById('live-output');
        
        // --- Helper Functions ---


// **** START OF CODE: Session Persistence Logic ****

        // This function gathers the current state of ALL elements on the page and saves it to localStorage.
        const saveCurrentStateToLocalStorage = () => {
            console.log("Auto-saving current session state...");
            // Create a state object, identical to how the "Export JSON" function works.
            const stateToSave = {};
            SECTIONS.forEach(id => {
                stateToSave[id] = [];
                document.querySelector(`.dropzone[data-section-id="${id}"]`).querySelectorAll('.draggable-element').forEach(el => {
                    stateToSave[id].push(getElementState(el));
                });
            });
            // Convert the object to a JSON string and store it.
            localStorage.setItem('dentalNoteMakerSession', JSON.stringify(stateToSave));
        };

       // This is the "Reset Values" function.
        const resetValues = () => {
            console.log("Resetting values to template defaults...");
            if (!lastLoadedState) {
                alert("No default template has been loaded to reset to.");
                return;
            }
            let resetCount = 0;
            document.querySelectorAll('.draggable-element').forEach(currentElement => {
                // Check the "do not reset" flag directly on the HTML element.
                if (currentElement.dataset.doNotReset === 'true') {
                    console.log(`Skipping reset for element: ${currentElement.dataset.originalId}`);
                    return; // Skip this element and move to the next one.
                }

                const originalId = currentElement.dataset.originalId;
                if (!originalId) return;

                // Find the original, pristine data from the template we loaded.
                const [sectionIndex, itemIndex] = originalId.split('-');
                const sectionKey = SECTIONS[sectionIndex];
                const defaultData = lastLoadedState[sectionKey]?.[itemIndex];
                
                if (defaultData) {
                    resetCount++;
                    // Create a fresh element from the default data and replace the current one.
                    const newElement = createElement(defaultData.type, defaultData);
                    currentElement.replaceWith(newElement);
                }
            });
            
            // This is crucial: after resetting, we must immediately update the live output,
            // which in turn triggers an auto-save of the newly reset state to localStorage.
            updateLiveOutput(); 

            // ---  Re-apply the lock state after resetting ---
            const lockToggle = document.getElementById('lock-layout-toggle');
            if (lockToggle.checked) {
                console.log("Reset complete. Re-applying layout lock.");
                // This will find all the newly created elements and correctly set draggable="false"
                lockToggle.dispatchEvent(new Event('change'));
            }
            // **** END OF lock reset CODE

            alert(`Reset ${resetCount} element(s) to their default values.`);





        };

// **** START OF FULL RESET CODE ****
        const fullReset = () => {
            // Ask for confirmation because this is a destructive action.
            if (confirm("Are you sure you want to perform a full reset? This will clear any saved work and restore the original template.")) {
                console.log("Performing a full reset. Clearing localStorage...");
                
                // 1. Clear the saved session from localStorage.
                localStorage.removeItem('dentalNoteMakerSession');
                
                // 2. Immediately reload the page.
                // This is the cleanest way to trigger the startup cascade, which will now
                // fail to find a localStorage session and will load the embedded JSON instead.
                window.location.reload();
            }
        };
        // **** END OF FULL RESET CODE ****


// **** END OF Session Persistence Logic ****



        // **** START OF palette CODE ****

const COLOR_PALETTE = [
    // Default & Blues
    { name: 'Default Blue', value: '#e6f7ff' },
    { name: 'Light Blue', value: '#d6eefb' },

    // Greens
    { name: 'Light Green', value: '#f6ffed' },
    { name: 'Mint Green', value: '#d9f7be' },
    
    // Reds & Pinks
    { name: 'Light Red', value: '#fff1f0' },
    { name: 'Light Pink', value: '#ffefff' },
    
    // Yellows & Oranges
    { name: 'Light Yellow', value: '#fffbe6' },
    { name: 'Light Orange', value: '#fff7e6' },
    { name: 'Gold', value: '#fff1b8' },

    // Purples
    { name: 'Light Purple', value: '#f9f0ff' },
    { name: 'Lavender', value: '#efdbff' },

    // Cyans & Teals
    { name: 'Light Cyan', value: '#e6fffb' },
    { name: 'Sky Blue', value: '#dcf4ff' },

    // Grays & Neutrals
    { name: 'White', value: '#ffffff' },
    { name: 'Light Gray 1', value: '#fafafa' },
    { name: 'Light Gray 2', value: '#f5f5f5' },
    { name: 'Light Gray 3', value: '#f0f0f0' },
    { name: 'Medium Gray', value: '#e8e8e8' },
    
    // Other
    { name: 'Beige', value: '#fffaf0' },
    { name: 'Aqua', value: '#e0ffff' }
];


        // **** END OF palette CODE ****




// **** START OF CODE: Note Evaluation Logic ****

       /**
         * Analyzes PSR scores from text and returns a risk assessment.
         * @param {string} psrText - The text containing PSR scores (can be multi-line).
         * @returns {string|null} The risk assessment string or null if not enough scores are found.
         */
         function evaluatePsr(psrText) {
            const matches = psrText.match(/[0-4]/g);
            if (!matches || matches.length < 6) { return null; }

            const scores = matches.map(m => parseInt(m, 10));
            const countOf3s = scores.filter(s => s === 3).length;
            const has4s = scores.some(s => s >= 4);

            // This now returns only the risk level string
            if (has4s || countOf3s >= 3) {
                return "HIGH";
            } else if (countOf3s >= 1 && countOf3s <= 2) {
                return "MODERATE";
            } else {
                return "LOW";
            }
        }


/**
         * Checks if a documented presenting complaint has a corresponding diagnosis.
         * @param {string[]} lines - An array of all lines in the note text.
         * @returns {string|null} The warning string or null if the check passes.
         */
        function checkComplaintDiagnosis(lines) {
            console.log("Evaluation: Checking Complaint/Diagnosis link...");
            
            // Find the relevant lines in the note.
            const complaintLine = lines.find(line => line.trim().startsWith("PRESENTING COMPLAINT:"));
            const diagnosisLine = lines.find(line => line.trim().startsWith("DIAGNOSIS OF FINDINGS AND/OR PRESENTING COMPLAINT:"));

            // If either line is missing, we can't perform the check.
            if (!complaintLine || !diagnosisLine) {
                console.log("Evaluation: Complaint or Diagnosis line not found.");
                return null;
            }

            // Extract the actual content after the label.
            const complaintText = complaintLine.replace("PRESENTING COMPLAINT:", "").trim();
            const diagnosisText = diagnosisLine.replace("DIAGNOSIS OF FINDINGS AND/OR PRESENTING COMPLAINT:", "").trim();

            console.log(`Evaluation: Complaint='${complaintText}', Diagnosis='${diagnosisText}'`);
            
            // Apply the logic: If complaint is NOT "None" but the diagnosis IS "None".
            // We use .toLowerCase() and .includes() to make the check robust against small variations like "none" or "None.".
            if (!complaintText.toLowerCase().includes('none') && diagnosisText.toLowerCase().includes('none')) {
                console.log("Evaluation: Mismatch FOUND!");
                return "No Diagnosis for Presenting Complaint given";
            }
            
            console.log("Evaluation: Complaint/Diagnosis check passed.");
            return null; // Check passed.
        }


       /**
         * Analyzes caries findings from the note to recommend a caries risk level.
         * @param {string[]} lines - An array of all lines in the note text.
         * @returns {string|null} The risk level string ("LOW", "MODERATE", "HIGH") or null.
         */
        function evaluateCariesRisk(lines) {
            console.log("Evaluation: Checking Caries Risk...");

            const defectiveLine = lines.find(line => line.trim().startsWith("CARIES/DEFECTIVE RESTORATIONS:"));
            const incipientLine = lines.find(line => line.trim().startsWith("INCIPIENT CARIES:"));

            // If we can't find the lines, we can't make a recommendation.
            if (!defectiveLine || !incipientLine) {
                console.log("Evaluation: Caries/Incipient lines not found.");
                return null;
            }

            // Use a regex to find all sequences of digits (\d+) globally (g).
            // The '|| []' ensures that if no numbers are found, we get an empty array instead of null.
            const defectiveMatches = defectiveLine.match(/\d+/g) || [];
            const incipientMatches = incipientLine.match(/\d+/g) || [];
            
            const defectiveCount = defectiveMatches.length;
            const incipientCount = incipientMatches.length;

            console.log(`Evaluation: Found ${defectiveCount} defective/carious teeth and ${incipientCount} incipient lesions.`);

            // Apply the risk logic you defined.
            if (defectiveCount > 2 || incipientCount > 4) {
                console.log("Evaluation: Result -> HIGH risk");
                return "HIGH";
            } else if (defectiveCount >= 1 || incipientCount >= 3) {
                console.log("Evaluation: Result -> MODERATE risk");
                return "MODERATE";
            } else {
                console.log("Evaluation: Result -> LOW risk");
                return "LOW";
            }
        }




        /**
         * Main evaluation router. It takes the full note text and runs all evaluation functions.
         * @param {string} noteText - The complete text from the live output.
         * @returns {string[]} An array of suggestion strings.
         */
        function evaluateNote(noteText) {
            console.log("--- Running Note Evaluation ---");
            const suggestions = [];
            
            const lines = noteText.split('\n');

            // --- Complaint/Diagnosis Check (runs first) ---
            const complaintSuggestion = checkComplaintDiagnosis(lines);
            if (complaintSuggestion) {
                suggestions.push(complaintSuggestion); // Use push, we will sort later if needed.
            }

            // --- Caries Risk Evaluation and Cross-Check (NEW) ---
            const recommendedCariesRisk = evaluateCariesRisk(lines);
            if (recommendedCariesRisk) {
                const userSelectedCariesLine = lines.find(line => line.trim().startsWith("CARIES RISK:"));
                let userSelectedCariesRisk = null;
                if (userSelectedCariesLine) {
                    const riskMatch = userSelectedCariesLine.match(/Low|Moderate|High/i);
                    if (riskMatch) {
                        userSelectedCariesRisk = riskMatch[0].toUpperCase();
                    }
                }

                let suggestionString = `Recommended Caries Risk: ${recommendedCariesRisk}`;
                if (userSelectedCariesRisk) {
                    if (recommendedCariesRisk === userSelectedCariesRisk) {
                        suggestionString += " (Matched)";
                    } else {
                        suggestionString += " (MISMATCH)";
                    }
                } else {
                    suggestionString += " (User selection not found)";
                }
                suggestions.push(suggestionString);
            }

            // --- Perio Risk Evaluation and Cross-Check ---
            const psrStartIndex = lines.findIndex(line => line.trim().startsWith("PSR:"));
            let recommendedPerioRisk = null;
            if (psrStartIndex !== -1) {
                const psrBlock = lines.slice(psrStartIndex, psrStartIndex + 3).join('\n');
                recommendedPerioRisk = evaluatePsr(psrBlock); 
            }
            const userSelectedRiskLine = lines.find(line => line.trim().startsWith("PERIO RISK:"));
            let userSelectedPerioRisk = null;
            if (userSelectedRiskLine) {
                const riskMatch = userSelectedRiskLine.match(/Low|Moderate|High/i);
                if (riskMatch) {
                    userSelectedPerioRisk = riskMatch[0].toUpperCase();
                }
            }
            if (recommendedPerioRisk) {
                let suggestionString = `Recommended Perio Risk: ${recommendedPerioRisk}`;
                if (userSelectedPerioRisk) {
                    if (recommendedPerioRisk === userSelectedPerioRisk) {
                        suggestionString += " (Matched)";
                    } else {
                        suggestionString += " (MISMATCH)";
                    }
                } else {
                    suggestionString += " (User selection not found)";
                }
                suggestions.push(suggestionString);
            }
            
            console.log("Evaluation complete. Suggestions:", suggestions);
            return suggestions;
        }
        // **** END OF CODE: Note Evaluation Logic ****











   const updateTxPlanSummary = (element) => { 
    const state = getElementState(element);
    const summarySpan = element.querySelector('.tx-plan-summary');
    const entryCount = Object.values(state.txData).filter(d => d.text && d.text.trim() !== '').length;
    summarySpan.textContent = entryCount > 0 ? `Treatment Plan: ${entryCount} Entries` : 'Click to set Treatment Plan'; 
};
   
   
   const getBPStatus = (s, d) => { if (!s || !d) return 'normal'; if (s >= 180 || d >= 120) return 'crisis'; if (s >= 140 || d >= 90) return 'stage2'; if (s >= 130 || d >= 85) return 'stage1'; if (s >= 120 && d < 80) return 'elevated'; return 'normal'; };
        const updateBPElementUI = (element) => { const s = parseInt(element.querySelector('.bp-systolic').value, 10); const d = parseInt(element.querySelector('.bp-diastolic').value, 10); const status = getBPStatus(s, d); element.classList.remove('bp-normal', 'bp-elevated', 'bp-stage1', 'bp-stage2', 'bp-crisis'); element.classList.add(`bp-${status}`); const priorTxContainer = element.querySelector('.bp-prior-tx-container'); const triggerS = parseInt(element.dataset.checkboxSystolic, 10); const triggerD = parseInt(element.dataset.checkboxDiastolic, 10); if (s >= triggerS || d >= triggerD) { priorTxContainer.classList.add('visible'); } else { priorTxContainer.classList.remove('visible'); } };
        const updatePSRElementUI = (element) => { const hasAsterisk = Array.from(element.querySelectorAll('.psr-asterisk')).some(cb => cb.checked); const noteContainer = element.querySelector('.psr-asterisk-note'); if (hasAsterisk) { noteContainer.classList.add('visible'); } else { noteContainer.classList.remove('visible'); } };
        const handlePSRTabbing = (event) => { if (event.key !== 'Tab') return; event.preventDefault(); const allInputs = Array.from(event.target.closest('.psr-grid').querySelectorAll('.psr-input')); const currentIndex = parseInt(event.target.dataset.index, 10); let nextIndex; if (event.shiftKey) { const reverseMap = new Map(Array.from(PSR_AUTOFOCUS_MAP.entries()).map(([k,v]) => [v,k])); nextIndex = reverseMap.get(currentIndex); if(nextIndex === undefined) nextIndex = 5; } else { nextIndex = PSR_AUTOFOCUS_MAP.get(currentIndex); if(nextIndex === undefined) nextIndex = 0; } const nextInput = allInputs.find(input => parseInt(input.dataset.index, 10) === nextIndex); if (nextInput) { nextInput.focus(); nextInput.select(); } };
        const padBox = (score) => `[${(score || '').padEnd(2)}]`;
        const updateAlertElementUI = (element) => { const state = getElementState(element); const display = element.querySelector('.alert-display'); element.classList.remove('alert-blank', 'alert-none', 'alert-active'); if (state.alerts.length === 0) { display.textContent = "ALERT (Click to set)"; element.classList.add('alert-blank'); } else if (state.alerts.length === 1 && state.alerts[0] === 'None') { display.textContent = "No Known Allergies"; element.classList.add('alert-none'); } else { display.textContent = `ALERT: ${state.alerts.length} active`; element.classList.add('alert-active'); } };
        const updateAnestheticSummary = (element) => { const state = getElementState(element); const summarySpan = element.querySelector('.anesthetic-summary'); const usedCount = Object.values(state.anestheticValues).filter(v => v > 0).length; summarySpan.textContent = usedCount > 0 ? `Anesthetic: ${usedCount} Type(s) Used` : 'Click to set anesthetic'; };
        const updateEndoTestingSummary = (element) => { const state = getElementState(element); const summarySpan = element.querySelector('.endo-summary'); const teethCount = state.endoData.teeth.filter(t => t && t.trim() !== '').length; summarySpan.textContent = teethCount > 0 ? `Endo Testing: ${teethCount} Teeth` : 'Click to set Endo Tests'; };

        // **** START OF NEW CODE for tx plan copy/paste ****
        const showFeedback = (message, isSuccess = true) => {
            const feedbackEl = document.getElementById('action-feedback');
            feedbackEl.textContent = message;
            feedbackEl.className = isSuccess ? 'success' : 'error';
            feedbackEl.style.display = 'block';
            feedbackEl.style.opacity = 1;
            setTimeout(() => {
                feedbackEl.style.opacity = 0;
                setTimeout(() => feedbackEl.style.display = 'none', 500);
            }, 2000);
        };
        // **** END OF NEW CODE ****

   
        const parseToothRange = (rangeStr) => { const teeth = new Set(); const parts = rangeStr.split(','); for (const part of parts) { if (part.includes('-')) { const [start, end] = part.split('-').map(Number); if (!isNaN(start) && !isNaN(end)) { for (let i = start; i <= end; i++) { teeth.add(String(i)); } } } else { const num = Number(part.trim()); if (!isNaN(num) && num > 0 && num < 33) { teeth.add(String(num)); } } } return Array.from(teeth).sort((a,b)=>a-b); };

        // --- Core: Element Creation & State ---
        const createDraggableContainer = (type, data) => {
            const draggable = document.createElement('div'); draggable.className = 'draggable-element';
            if (data.isHidden) draggable.classList.add('element-hidden');
            draggable.dataset.type = type;
            if (data.doNotReset) draggable.dataset.doNotReset = 'true';
            if (data.originalId) draggable.dataset.originalId = data.originalId;
            if (data.required) draggable.dataset.required = 'true'; 

           // **** START OF CODE for width****
            // Check for and apply the custom width
            if (data.width) {
                draggable.style.width = data.width;
                draggable.dataset.width = data.width;
            }
            // **** END OF width CODE ****


            // **** START OF color CODE ****
            // Check for and apply the custom fill color
            if (data.fillColor) {
                draggable.style.backgroundColor = data.fillColor;
                draggable.dataset.fillColor = data.fillColor;
            }
            // **** END OF color CODE ****




if (data.prefixTab) draggable.dataset.prefixTab = 'true'; if (data.prefixNewline) draggable.dataset.prefixNewline = 'true'; if (data.suffixNewline) draggable.dataset.suffixNewline = 'true';
            if (type === 'enhanced-textbox') { draggable.dataset.internalLabel = data.internalLabel || ''; draggable.dataset.prefixLabel = data.prefixLabel || ''; draggable.dataset.defaultText = data.defaultText || "Click to edit..."; draggable.dataset.dropdownOptions = JSON.stringify(data.dropdownOptions || []); draggable.dataset.content = data.content || data.defaultText; }
            else if (type === 'alert') { draggable.dataset.alerts = JSON.stringify(data.alerts || []); }
            else if (type === 'bloodpressure') { draggable.dataset.discussSystolic = data.discussSystolic || '130'; draggable.dataset.discussDiastolic = data.discussDiastolic || '80'; draggable.dataset.checkboxSystolic = data.checkboxSystolic || '140'; draggable.dataset.checkboxDiastolic = data.checkboxDiastolic || '90'; }   
   else if (type === 'anesthetic') { draggable.dataset.anestheticTypes = JSON.stringify(data.anestheticTypes || [ { name: '2% Lidocaine', mg: 34, epi: 17 }, { name: '4% Septocaine', mg: 68, epi: 17 }, { name: '0.5% Marcaine', mg: 9, epi: 9 } ]); draggable.dataset.anestheticValues = JSON.stringify(data.anestheticValues || {}); draggable.dataset.includeTopical = data.includeTopical === false ? 'false' : 'true';}
 
            else if (type === 'tx-plan') {
                draggable.dataset.txRows = JSON.stringify(data.txRows || ["Oral Hygiene", "Operative", "Perio", "Oral Surgery", "Endo", "Pros", "Other"]);
draggable.dataset.txSnippets = JSON.stringify(data.txSnippets || []);
                draggable.dataset.txData = JSON.stringify(data.txData || {});
            }    
   
   else if (type === 'endo-testing') { draggable.dataset.endoTests = JSON.stringify(data.endoTests || ["Percussion", "Palpation", "Endo Ice", "Tooth Slooth", "Periodontal", "Mobility", "Transillumination"]); draggable.dataset.endoData = JSON.stringify(data.endoData || { teeth: [''], results: {} }); }
            draggable.draggable = true; draggable.id = `element-${Date.now()}-${Math.random()}`;
            draggable.addEventListener('dragstart', e => e.target.classList.add('dragging'));
            draggable.addEventListener('dragend', e => e.target.classList.remove('dragging'));
            draggable.addEventListener('contextmenu', e => { e.preventDefault(); activeElementForEditor = e.target.closest('.draggable-element'); const contextMenu = document.getElementById('context-menu'); 




contextMenu.style.top = `${e.clientY + window.scrollY}px`; contextMenu.style.left = `${e.clientX}px`; contextMenu.style.display = 'block'; });

// **** START OF NEW CODE ****
    // Add a simple click listener to add the highlight class
    draggable.addEventListener('click', (e) => { draggable.classList.add('element-highlighted');});
    // **** END OF NEW CODE ****

            return draggable;
        };

        const createElement = (type, data = {}) => {
            const draggable = createDraggableContainer(type, data);
            if (!['enhanced-textbox', 'alert', 'anesthetic', 'endo-testing', 'label-red', 'label-black', 'formatter'].includes(type)) {
                 draggable.addEventListener('input', updateLiveOutput);
            }
            if (type === 'enhanced-textbox') { draggable.classList.add('enhanced-textbox'); const internalLabelHtml = data.internalLabel ? `<div class="internal-label">${data.internalLabel}</div>` : ''; draggable.innerHTML = `${internalLabelHtml}<div class="enhanced-textbox-preview">${data.content || data.defaultText || ''}</div>`; draggable.addEventListener('click', () => openTextboxEditor(draggable)); }
            else if (type === 'alert') { draggable.classList.add('alert-element'); draggable.innerHTML = `<span class="alert-display"></span>`; draggable.addEventListener('click', () => openAllergyModal(draggable)); updateAlertElementUI(draggable); }
            else if (type === 'anesthetic') { draggable.classList.add('anesthetic-element'); draggable.innerHTML = `<span class="anesthetic-summary"></span>`; updateAnestheticSummary(draggable); draggable.addEventListener('click', () => openAnestheticEditor(draggable)); }

    // **** START OF NEW CODE for tx plan ****
            else if (type === 'tx-plan') {
                draggable.classList.add('tx-plan-element');
                draggable.innerHTML = `<span class="tx-plan-summary"></span>`;
                updateTxPlanSummary(draggable);
                draggable.addEventListener('click', () => openTxPlanEditor(draggable));
            }
            // **** END OF NEW CODE ****
   
   
   else if (type === 'endo-testing') { draggable.classList.add('endo-testing-element'); draggable.innerHTML = `<span class="endo-summary"></span>`; updateEndoTestingSummary(draggable); draggable.addEventListener('click', () => openEndoTestingEditor(draggable)); }
            else if (type === 'painscale') { const val = data.value || 0; draggable.innerHTML = `<label>Pain Scale: <b class="pain-value">${val}/10</b></label><div class="pain-scale-container"><input type="range" min="0" max="10" value="${val}" class="pain-slider"></div>`; draggable.querySelector('.pain-slider').addEventListener('input', e => { draggable.querySelector('.pain-value').textContent = `${e.target.value}/10`; }); }
            else if (type === 'bloodpressure') { draggable.classList.add('bp-element'); draggable.innerHTML = `<div class="bp-inputs"><b>BP:</b> <input type="number" class="bp-systolic" placeholder="120" value="${data.systolic || ''}"> / <input type="number" class="bp-diastolic" placeholder="80" value="${data.diastolic || ''}"></div><div class="bp-prior-tx-container"><label><input type="checkbox" class="bp-prior-tx-check" ${data.isPriorTxChecked ? 'checked' : ''}> BP Prior to Tx</label></div>`; draggable.querySelectorAll('input[type="number"]').forEach(input => { input.addEventListener('input', () => updateBPElementUI(draggable)); }); updateBPElementUI(draggable); }
            else if (type === 'psr') { draggable.classList.add('psr-element'); const scores = data.scores || Array(6).fill(''); const asterisks = data.asterisks || Array(6).fill(false); const visualOrder = [[0, "[1]"], [1, "[2]"], [2, "[3]"], [5, "[6]"], [4, "[5]"], [3, "[4]"]]; let gridHtml = ''; [visualOrder.slice(0,3), visualOrder.slice(3,6)].forEach(row => { gridHtml += row.map(([index, label]) => `<div class="psr-sextant"><input type="checkbox" class="psr-asterisk" data-index="${index}" ${asterisks[index] ? 'checked' : ''}><label>${label}</label><input type="text" class="psr-input" value="${scores[index]}" data-index="${index}"></div>`).join(''); }); draggable.innerHTML = `<b>PSR:</b><div class="psr-grid">${gridHtml}</div><textarea class="psr-asterisk-note" placeholder="* Description...">${data.asteriskNote || ''}</textarea>`; draggable.querySelectorAll('.psr-input').forEach(input => { input.addEventListener('input', () => { const index = parseInt(input.dataset.index, 10); const checkbox = draggable.querySelector(`.psr-asterisk[data-index="${index}"]`); if (input.value.includes('*')) { if (!checkbox.checked) checkbox.checked = true; } else { if (checkbox.checked) checkbox.checked = false; } const scorePart = input.value.replace(/\*/g, ''); if (scorePart.length > 1) input.value = scorePart.charAt(0) + (checkbox.checked ? '*' : ''); if (!scorePart.match(/^[0-4]?$/)) input.value = '' + (checkbox.checked ? '*' : ''); if (scorePart.length === 1 && scorePart.match(/[0-4]/)) { const nextIndex = PSR_AUTOFOCUS_MAP.get(index); if (nextIndex !== undefined) { const nextInput = draggable.querySelector(`.psr-input[data-index="${nextIndex}"]`); if (nextInput) { nextInput.focus(); nextInput.select(); } } } updatePSRElementUI(draggable); }); input.addEventListener('keydown', handlePSRTabbing); }); draggable.querySelectorAll('.psr-asterisk').forEach(checkbox => { checkbox.addEventListener('change', () => { const index = parseInt(checkbox.dataset.index, 10); const input = draggable.querySelector(`.psr-input[data-index="${index}"]`); const scorePart = input.value.replace(/\*/g, ''); input.value = scorePart + (checkbox.checked ? '*' : ''); updatePSRElementUI(draggable); updateLiveOutput(); }); }); updatePSRElementUI(draggable); }
            else if (type === 'dropdown') { const select = document.createElement('select'); (data.options || ['Select...', 'Opt 1', 'Opt 2']).forEach(opt => select.add(new Option(opt, opt, false, opt === data.selected))); draggable.appendChild(select); draggable.addEventListener('change', updateLiveOutput); }
            else if (type === 'checkbox') { draggable.innerHTML = `<label><input type="checkbox" ${data.checked ? 'checked' : ''}> <span contenteditable="true">${data.content || 'Checkbox text'}</span></label>`; }
            else if (type.startsWith('label-')) { draggable.classList.add(type === 'label-red' ? 'element-label-red' : 'element-label-black'); draggable.innerHTML = `<div contenteditable="true">${data.content || 'Descriptive Label'}</div>`; }
            else if (type === 'formatter') { draggable.classList.add('formatter-element'); const formatType = data.formatType || 'newline'; let display = (formatType === 'newline') ? '↵ Newline' : (formatType === 'tab') ? '→ Tab' : (data.customChars || '...'); draggable.innerHTML = `<span>${display}</span>`; }
            return draggable;
        };

        const getElementState = (element) => {
            const type = element.dataset.type;             const state = { type, required: element.dataset.required === 'true', prefixTab: element.dataset.prefixTab === 'true', prefixNewline: element.dataset.prefixNewline === 'true', suffixNewline: element.dataset.suffixNewline === 'true', originalId: element.dataset.originalId, isHidden: element.classList.contains('element-hidden'), doNotReset: element.dataset.doNotReset === 'true', width: element.dataset.width || '', fillColor: element.dataset.fillColor || '' };
            if (type === 'enhanced-textbox') { state.content = element.dataset.content; state.internalLabel = element.dataset.internalLabel; state.prefixLabel = element.dataset.prefixLabel; state.defaultText = element.dataset.defaultText; state.dropdownOptions = JSON.parse(element.dataset.dropdownOptions); }

            // **** START OF NEW CODE for tx plan****
            else if (type === 'tx-plan') {
                state.txRows = JSON.parse(element.dataset.txRows);
state.txSnippets = JSON.parse(element.dataset.txSnippets);
                state.txData = JSON.parse(element.dataset.txData);
            }
            // **** END OF NEW CODE ****
   
            else if (type === 'alert') { state.alerts = JSON.parse(element.dataset.alerts || '[]'); }
            else if (type === 'painscale') { state.value = element.querySelector('.pain-slider').value; }
            else if (type === 'anesthetic') { state.anestheticTypes = JSON.parse(element.dataset.anestheticTypes); state.anestheticValues = JSON.parse(element.dataset.anestheticValues); state.includeTopical = element.dataset.includeTopical === 'true'; }
            else if (type === 'endo-testing') { state.endoTests = JSON.parse(element.dataset.endoTests); state.endoData = JSON.parse(element.dataset.endoData); }
            else if (type === 'bloodpressure') { state.systolic = element.querySelector('.bp-systolic').value; state.diastolic = element.querySelector('.bp-diastolic').value; state.isPriorTxChecked = element.querySelector('.bp-prior-tx-check').checked; state.discussSystolic = element.dataset.discussSystolic; state.discussDiastolic = element.dataset.discussDiastolic; state.checkboxSystolic = element.dataset.checkboxSystolic; state.checkboxDiastolic = element.dataset.checkboxDiastolic; }
            else if (type === 'psr') { state.scores = Array(6).fill(''); state.asterisks = Array(6).fill(false); element.querySelectorAll('.psr-input').forEach(i => { state.scores[i.dataset.index] = i.value; }); element.querySelectorAll('.psr-asterisk').forEach(cb => { state.asterisks[cb.dataset.index] = cb.checked; }); state.asteriskNote = element.querySelector('.psr-asterisk-note').value; }
            else if (type === 'dropdown') { const select = element.querySelector('select'); state.options = Array.from(select.options).map(o => o.value); state.selected = select.value; }
            else if (type === 'checkbox') { state.checked = element.querySelector('input').checked; state.content = element.querySelector('span').innerText; }
            else if (type.startsWith('label-')) { state.content = element.querySelector('[contenteditable]').innerText; }
            else if (type === 'formatter') { state.formatType = element.dataset.formatType || 'newline'; state.customChars = element.dataset.customChars || ''; }
            return state;
        };
        
        const updateLiveOutput = () => {
            let outputParts = [];
            document.querySelectorAll('.draggable-element').forEach(el => {
                const state = getElementState(el); let content = '';
                if (state.type === 'enhanced-textbox') { if(state.content && state.content.trim() !== "") { const prefix = state.prefixLabel ? `${state.prefixLabel} ` : ''; content = prefix + state.content; } }

                // **** START OF NEW CODE for tx plan****
                else if (state.type === 'tx-plan') {
                    const classOrder = ["CLASS 3", "CLASS 2", "CLASS 1"];
                    let planParts = [];
                    classOrder.forEach(className => {
                        let classContent = [];
                        for (let priority = 1; priority <= 5; priority++) {
                            let priorityItems = [];
                            state.txRows.forEach(rowName => {
   const key = `${rowName}-${className}`;
                        if (state.txData[key] && state.txData[key].priority === priority && state.txData[key].text.trim() !== '') {
                            // **** START OF MODIFIED LINE ****
                            // Add the row name as a prefix to the treatment text
                            priorityItems.push(`${rowName}: ${state.txData[key].text}`);
                            // **** END OF MODIFIED LINE ****
                        }
                    });
                            if (priorityItems.length > 0) {
                                classContent.push(`${priority}) ${priorityItems.join(', ')}`);
                            }
                        }
                        if (classContent.length > 0) {
                            planParts.push(`${className}:\n     ${classContent.join('\n     ')}`);
                        }
                    });
                    content = planParts.join('\n');
                }
                // **** END OF NEW CODE ****

                else if (state.type === 'anesthetic') { let an_parts = []; if (state.includeTopical) { an_parts.push('Topical Anesthetic.'); } for (const [name, carpules] of Object.entries(state.anestheticValues)) { if (carpules > 0) { const typeInfo = state.anestheticTypes.find(t => t.name === name); if (typeInfo) { const totalMg = parseFloat((typeInfo.mg * carpules).toPrecision(3)); const totalEpi = parseFloat((typeInfo.epi * carpules).toPrecision(3)); an_parts.push(`[${totalMg} MILLIGRAMS ${name} ${totalEpi} MICROGRAMS EPI.]`); } } } content = an_parts.join(' '); }


        // **** START OF REPLACEMENT CODE BLOCK for tab delimited endo testing ****

        else if (state.type === 'endo-testing') {
            const data = state.endoData; 
            const tests = state.endoTests;
            const activeTeethIndices = data.teeth
                .map((tooth, i) => (tooth && tooth.trim() !== '' && Object.values(data.results).some(testRow => testRow[i] && testRow[i].trim() !== '')) ? i : -1)
                .filter(i => i !== -1);
            
            if (activeTeethIndices.length > 0) {
                const activeTeeth = activeTeethIndices.map(i => data.teeth[i]);
                const activeTests = tests.filter(testName => data.results[testName] && activeTeethIndices.some(i => data.results[testName][i] && data.results[testName][i].trim() !== ''));
                
                if (activeTests.length > 0) {
                    // Define the non-breaking space character for padding
                    const nbsp = '\u2002'; 

                    // 1. Calculate the maximum width needed for each column
                    const colWidths = activeTeeth.map((tooth, i) => {
                        let maxWidth = tooth.length;
                        activeTests.forEach(testName => {
                            const result = data.results[testName]?.[activeTeethIndices[i]] || '';
                            if (result.length > maxWidth) maxWidth = result.length;
                        });
                        return maxWidth;
                    });

                    // 2. Build the output using padEnd and the non-breaking space
                    const header = 'Endo Tests'.padEnd(20, nbsp) + ' | ' + activeTeeth.map((tooth, i) => tooth.padEnd(colWidths[i], nbsp)).join(' | ');
                    
                    const separator = '-'.repeat(20) + '-+-' + colWidths.map(w => '-'.repeat(w)).join('-+-');
                    
                    const rows = activeTests.map(testName => {
                        const rowData = data.results[testName] || [];
                        const rowResults = activeTeethIndices.map((toothIndex, i) => (rowData[toothIndex] || '').padEnd(colWidths[i], nbsp));
                        return testName.padEnd(20, nbsp) + ' | ' + rowResults.join(' | ');
                    });
                    
                    content = [header, separator, ...rows].join('\n');
                }
            }
        }

        // **** END OF REPLACEMENT CODE BLOCK ****


                else if (state.type === 'alert') { if (state.alerts.length > 0) { if (state.alerts[0] === 'None') { content = 'ALERT: No Known Allergies'; } else { content = 'ALERT: ' + state.alerts.map(a => a === 'PREGNANCY' ? 'PREGNANCY' : a.startsWith('Custom: ') ? a.substring(8) : `${a} ALLERGY`).join(', '); } } else if (state.required) { content = 'ALERT: [BLANK]'; } }
                else if (state.type === 'painscale') { if (!state.required || state.value > 0) content = `PAIN: ${state.value}/10`; }
                else if (state.type === 'bloodpressure') { if (state.systolic && state.diastolic) { content = `BP ${state.systolic}/${state.diastolic}`; if (parseInt(state.systolic) >= parseInt(state.discussSystolic) || parseInt(state.diastolic) >= parseInt(state.discussDiastolic)) content += " (BP discussed)"; if (state.isPriorTxChecked && (parseInt(state.systolic) >= parseInt(el.dataset.checkboxSystolic) || parseInt(state.diastolic) >= parseInt(el.dataset.checkboxDiastolic))) content += ` (BP prior to treatment: ${state.systolic}/${state.diastolic})`; } }
                else if (state.type === 'psr') { const scores = state.scores; const topRow = `     ${padBox(scores[0])} ${padBox(scores[1])} ${padBox(scores[2])}`; const botRow = `     ${padBox(scores[5])} ${padBox(scores[4])} ${padBox(scores[3])}`; content = `PSR:\n${topRow}\n${botRow}`; if (state.asterisks.some(a => a) && state.asteriskNote.trim()) { content += `\n     (*: ${state.asteriskNote.trim()})`; } }
                else if (state.type === 'dropdown') { if (el.querySelector('select').selectedIndex > 0 || !state.required) content = el.querySelector('select').value; }
                else if (state.type === 'checkbox') { if(el.querySelector('input').checked) content = el.querySelector('span').innerText; }
                else if (state.type === 'formatter') { if (state.formatType === 'newline') content = '\n'; else if (state.formatType === 'tab') content = '     '; else content = state.customChars; }
                if (content || state.type === 'formatter') { let prefix = (state.prefixNewline ? '\n' : '') + (state.prefixTab ? '     ' : ''); let suffix = state.suffixNewline ? '\n' : ''; outputParts.push(prefix + content + suffix); }
            });
            liveOutput.value = outputParts.join('');

// Auto-save the entire state to the browser's local storage on every change.
            saveCurrentStateToLocalStorage();

// Update Charting on every change.
		generateChart();

        };


        
        // --- UI & Event Handlers ---

        // **** START OF REPLACEMENT JAVASCRIPT ****

        // --- Textbox Selection-to-Treatment-Plan Logic ---
        const textboxEditorTextarea = document.getElementById('textbox-editor-textarea');
        const selectionActionsDiv = document.getElementById('selection-actions');

        // This function runs when a user clicks one of the "Send To" buttons
        const copySelectedTextToTxPlan = (targetClass) => {
            const selectedText = textboxEditorTextarea.value.substring(textboxEditorTextarea.selectionStart, textboxEditorTextarea.selectionEnd).trim();
            if (!selectedText) return;

            const txPlanElement = document.querySelector('.draggable-element[data-type="tx-plan"]');
            if (!txPlanElement) {
                showFeedback("No Treatment Plan element available", false);
                return;
            }

            const state = getElementState(txPlanElement);
            const key = `Operative-${targetClass}`; // Hardcoded to "Operative" row

            const existingEntry = state.txData[key] || { text: '', priority: 0 };
            const newText = existingEntry.text ? `${existingEntry.text}, ${selectedText}` : selectedText;
            const newPriority = existingEntry.priority > 0 ? existingEntry.priority : 1; // Default to priority 1

            state.txData[key] = { text: newText, priority: newPriority };

            txPlanElement.dataset.txData = JSON.stringify(state.txData);
            updateTxPlanSummary(txPlanElement);
            updateLiveOutput();
            showFeedback("Copied to Treatment Plan!");
        };
        
        // Listen for clicks on any of our new action buttons
        selectionActionsDiv.addEventListener('click', (e) => {
            if (e.target.classList.contains('selection-action-btn')) {
                copySelectedTextToTxPlan(e.target.dataset.targetClass);
            }
        });

        // Listen for any change in text selection within the document
        document.addEventListener('selectionchange', () => {
            const selection = window.getSelection();
            const isTextareaFocused = document.activeElement === textboxEditorTextarea;
            
            // Show the action bar only if the textarea is focused and has selected text
            if (isTextareaFocused && selection.toString().trim().length > 0) {
                selectionActionsDiv.style.display = 'block';
            } else {
                selectionActionsDiv.style.display = 'none';
            }
        });
        
        // **** END OF REPLACEMENT JAVASCRIPT ****
   
   
   
   const textboxEditorModal = document.getElementById('textbox-editor-modal'); const openTextboxEditor = (element) => { activeElementForEditor = element; const state = getElementState(element); const textarea = document.getElementById('textbox-editor-textarea'); const select = document.getElementById('textbox-editor-select'); textarea.value = state.content; select.innerHTML = ''; state.dropdownOptions.forEach(opt => select.add(new Option(opt, opt))); textboxEditorModal.style.display = 'block'; 
																													  
// this is where the textbox editor focus gets set
textboxEditorTextarea.focus();
if (textarea.value === activeElementForEditor.dataset.defaultText) { textboxEditorTextarea.select();};																									  
																													  
																													  }; document.getElementById('textbox-editor-add-btn').onclick = () => { if (!activeElementForEditor) return; const textarea = document.getElementById('textbox-editor-textarea'); const select = document.getElementById('textbox-editor-select'); const defaultText = activeElementForEditor.dataset.defaultText; const selectedValue = select.value.replace(/\\n/g, '\n'); if (!selectedValue) return; if (textarea.value === defaultText || textarea.value.trim() === '') { textarea.value = selectedValue; } else { textarea.value += `, ${selectedValue}`; } }; 



document.getElementById('textbox-editor-replace-btn').onclick = () => {
    if (!activeElementForEditor) return;
    const textarea = document.getElementById('textbox-editor-textarea');
    const select = document.getElementById('textbox-editor-select');

    // Get the selected value and replace the user-typed '\\n' with a real newline character.
    const selectedValue = select.value.replace(/\\n/g, '\n');

    // This is a standard textarea, so we can just assign the processed value directly.
    textarea.value = selectedValue;
};


// **** START OF NEW CODE for double click**** 
// Add double-click functionality to the dropdown list 
document.getElementById('textbox-editor-select').addEventListener('dblclick', (e) => { 
// Trigger the same logic as the 'Add' --> replace button 
document.getElementById('textbox-editor-replace-btn').click(); }); 
// **** END OF NEW CODE ****
   

// **** START OF NEW CODE for tx plan ****
        // --- Treatment Plan Modal Logic ---
        const txPlanModal = document.getElementById('tx-plan-modal');

        // **** START OF REPLACEMENT CODE with upgraded visibility ****

        const openTxPlanEditor = (element) => {
            activeElementForEditor = element;
            const state = getElementState(element);
            const table = txPlanModal.querySelector('#tx-plan-table');
            table.innerHTML = ''; // Clear old content

            // Header
            const thead = table.createTHead();
            const headerRow = thead.insertRow();
            headerRow.innerHTML = '<th>Department</th><th>CLASS 3</th><th>CLASS 2</th><th>CLASS 1</th>';

            // Snippet Options HTML
            const snippetOptionsHtml = state.txSnippets.map(opt => `<option value="${opt}">${opt}</option>`).join('');

            // Body
            const tbody = table.createTBody();
            state.txRows.forEach(rowName => {
                const row = tbody.insertRow();
                // Change 1: Add a class to the row header cell
                row.insertCell().outerHTML = `<td class="tx-row-header">${rowName}</td>`;

                ["CLASS 3", "CLASS 2", "CLASS 1"].forEach(className => {
                    const cell = row.insertCell();
                    const key = `${rowName}-${className}`;
                    const data = state.txData[key] || { text: '', priority: 1 };
                    
                    let priorityOptions = '<option value="0">--</option>';
                    for(let i = 1; i <= 5; i++) {
                        priorityOptions += `<option value="${i}" ${data.priority === i ? 'selected' : ''}>${i}</option>`;
                    }

                    // Change 2: Add the "Priority Level" label and the `has-content` class if needed
                    const hasContentClass = data.text ? 'has-content' : '';
                    cell.innerHTML = `
                        <div class="cell-content">
                            <div>
                                <label class="priority-label">Priority Level</label>
                                <select class="priority-select" data-key="${key}">${priorityOptions}</select>
                            </div>
                            <textarea class="${hasContentClass}" data-key="${key}">${data.text}</textarea>
                            <select class="snippet-select"><option value="">-- Add Snippet --</option>${snippetOptionsHtml}</select>
                        </div>
                    `;
                });
            });

            // Snippet adding and has-content logic
            tbody.addEventListener('change', e => {
                if (e.target.classList.contains('snippet-select')) {
                    const select = e.target;
                    if (select.value) {
                        const textarea = select.closest('.cell-content').querySelector('textarea');
                        textarea.value += (textarea.value.trim() ? ', ' : '') + select.value;
                        textarea.classList.add('has-content'); // Add class when snippet is added
                        select.selectedIndex = 0;
                    }
                }
            });

            // Change 3: Add input event listener to toggle the green border
            tbody.addEventListener('input', e => {
                if (e.target.tagName === 'TEXTAREA') {
                    if (e.target.value.trim() !== '') {
                        e.target.classList.add('has-content');
                    } else {
                        e.target.classList.remove('has-content');
                    }
                }
            });

            txPlanModal.style.display = 'block';
        };

        // **** END OF REPLACEMENT CODE ****

        document.getElementById('tx-plan-save-btn').onclick = () => {
            if (!activeElementForEditor) return;
            const newData = {};
            txPlanModal.querySelectorAll('tbody .cell-content').forEach(cellContent => {
                const textarea = cellContent.querySelector('textarea');
                const prioritySelect = cellContent.querySelector('.priority-select');
                const key = textarea.dataset.key;
                const priority = parseInt(prioritySelect.value, 10);
                const text = textarea.value.trim();
                
                if (text && priority > 0) {
                    newData[key] = { text, priority };
                }
            });
            activeElementForEditor.dataset.txData = JSON.stringify(newData);
            updateTxPlanSummary(activeElementForEditor);
            updateLiveOutput();
            txPlanModal.style.display = 'none';
        };

        // --- Treatment Plan Properties ---
        const openTxPlanProperties = (state, body) => {
            return `
                <fieldset>
                    <legend>Treatment Plan Rows</legend>
                    <label>(one per line)</label>
                    <textarea id="prop-tx-rows" rows="8">${state.txRows.join('\n')}</textarea>
                </fieldset>
                <fieldset>
                    <legend>Quick-Add Snippets</legend>
                    <label>(one per line)</label>
                    <textarea id="prop-tx-snippets" rows="6">${state.txSnippets.join('\n')}</textarea>
                </fieldset>
            `;
        };
        
        const saveTxPlanProperties = (newState, element) => {
            newState.txRows = document.getElementById('prop-tx-rows').value.split('\n').filter(line => line.trim() !== '');
            newState.txSnippets = document.getElementById('prop-tx-snippets').value.split('\n').filter(line => line.trim() !== '');
            newState.txData = {}; // Reset data when properties change
        };
        // **** END OF NEW CODE ****


   

document.getElementById('textbox-editor-save-btn').onclick = () => { if (!activeElementForEditor) return; const newContent = document.getElementById('textbox-editor-textarea').value; activeElementForEditor.dataset.content = newContent; activeElementForEditor.querySelector('.enhanced-textbox-preview').textContent = newContent; updateLiveOutput(); textboxEditorModal.style.display = 'none'; };






        const anestheticEditorModal = document.getElementById('anesthetic-editor-modal'); const openAnestheticEditor = (element) => { activeElementForEditor = element; const state = getElementState(element); const listDiv = document.getElementById('anesthetic-editor-list'); listDiv.innerHTML = ''; document.getElementById('anesthetic-topical-check').checked = state.includeTopical; state.anestheticTypes.forEach(type => { const currentValue = state.anestheticValues[type.name] || 0; const row = document.createElement('div'); row.className = 'anesthetic-row'; row.innerHTML = `<label>${type.name}</label><input type="number" value="${currentValue}" min="0" step="0.25" data-name="${type.name}">`; listDiv.appendChild(row); }); anestheticEditorModal.style.display = 'block'; }; document.getElementById('anesthetic-editor-save-btn').onclick = () => { if (!activeElementForEditor) return; const newValues = {}; document.querySelectorAll('#anesthetic-editor-list input').forEach(input => { newValues[input.dataset.name] = parseFloat(input.value) || 0; }); activeElementForEditor.dataset.anestheticValues = JSON.stringify(newValues); activeElementForEditor.dataset.includeTopical = document.getElementById('anesthetic-topical-check').checked; updateAnestheticSummary(activeElementForEditor); updateLiveOutput(); anestheticEditorModal.style.display = 'none'; }; const createAnestheticTypeRow = (type = {name: '', mg: '', epi: ''}) => { const row = document.createElement('div'); row.className = 'prop-anesthetic-row'; row.innerHTML = `<input type="text" class="prop-anesthetic-name" value="${type.name}" placeholder="Name"> <input type="number" class="prop-anesthetic-mg" value="${type.mg}" placeholder="mg/carp"> <input type="number" class="prop-anesthetic-epi" value="${type.epi}" placeholder="epi/carp"> <span class="remove-btn">✖</span>`; row.querySelector('.remove-btn').onclick = () => row.remove(); return row; };
        const endoModal = document.getElementById('endo-testing-modal'); const openEndoTestingEditor = (element) => { activeElementForEditor = element; const state = getElementState(element); const tableHead = endoModal.querySelector('thead'); const tableBody = endoModal.querySelector('tbody'); tableHead.innerHTML = ''; tableBody.innerHTML = ''; const headerRow = document.createElement('tr'); headerRow.innerHTML = '<th>Test</th>'; const teethToDisplay = [...state.endoData.teeth]; if (teethToDisplay.length === 0 || teethToDisplay[teethToDisplay.length - 1] !== '') { teethToDisplay.push(''); } teethToDisplay.forEach((tooth, index) => { headerRow.innerHTML += `<th><input type="text" value="${tooth}" class="endo-tooth-input" data-index="${index}" placeholder="#"></th>`; }); tableHead.appendChild(headerRow); state.endoTests.forEach(testName => { const testRow = document.createElement('tr'); testRow.innerHTML = `<td>${testName}</td>`; teethToDisplay.forEach((_, index) => { const result = state.endoData.results[testName]?.[index] || ''; testRow.innerHTML += `<td><input type="text" value="${result}" data-test="${testName}" data-index="${index}"></td>`; }); tableBody.appendChild(testRow); }); endoModal.style.display = 'block'; }; document.getElementById('endo-range-add-btn').onclick = () => { if (!activeElementForEditor) return; const rangeInput = document.getElementById('endo-range-input'); const newTeeth = parseToothRange(rangeInput.value); const state = getElementState(activeElementForEditor); const existingTeeth = new Set(state.endoData.teeth.filter(t => t && t.trim() !== '')); newTeeth.forEach(t => existingTeeth.add(t)); const sortedTeeth = Array.from(existingTeeth).sort((a,b)=>a-b); state.endoData.teeth = sortedTeeth; activeElementForEditor.dataset.endoData = JSON.stringify(state.endoData); openEndoTestingEditor(activeElementForEditor); rangeInput.value = ''; }; document.getElementById('endo-testing-save-btn').onclick = () => { if (!activeElementForEditor) return; const teeth = Array.from(endoModal.querySelectorAll('.endo-tooth-input')).map(input => input.value.trim()); const results = {}; endoModal.querySelectorAll('tbody input').forEach(input => { const test = input.dataset.test; const index = parseInt(input.dataset.index, 10); if (!results[test]) { results[test] = []; } results[test][index] = input.value; }); activeElementForEditor.dataset.endoData = JSON.stringify({ teeth, results }); updateEndoTestingSummary(activeElementForEditor); updateLiveOutput(); endoModal.style.display = 'none'; };
        const openPropertiesModal = (element) => {
            const state = getElementState(element); const body = document.getElementById('properties-body'); let mainPropsHtml = '', formattingHtml = '', generalPropsHtml = '';
            if (state.type === 'enhanced-textbox') { mainPropsHtml = `<fieldset><legend>Labels & Text</legend><label for="prop-internal-label">Internal Label (for maker only)</label><input type="text" id="prop-internal-label" value="${state.internalLabel}"><label for="prop-prefix-label">Prefix Label (for note output)</label><input type="text" id="prop-prefix-label" value="${state.prefixLabel}"><label for="prop-default-text">Default Text</label><input type="text" id="prop-default-text" value="${state.defaultText}"></fieldset><fieldset><legend>Dropdown Phrases</legend><label for="prop-dropdown-options">(one per line)</label><textarea id="prop-dropdown-options" rows="6">${state.dropdownOptions.join('\n')}</textarea></fieldset>`; }
            else if (state.type === 'anesthetic') { mainPropsHtml = `<fieldset><legend>Anesthetic Types</legend><div id="prop-anesthetic-types"></div><button id="prop-add-anesthetic-type" class="control-btn" style="margin-top:10px;">+ Add Type</button></fieldset>`; }

            // **** START OF NEW CODE for tx plan****
            else if (state.type === 'tx-plan') { mainPropsHtml = openTxPlanProperties(state, body); }
            // **** END OF NEW CODE ****



   
            else if (state.type === 'endo-testing') { mainPropsHtml = `<fieldset><legend>Test Rows</legend><label>(one per line)</label><textarea id="prop-endo-tests" rows="8">${state.endoTests.join('\n')}</textarea></fieldset>`; }
            else if (state.type === 'bloodpressure') { mainPropsHtml = `<fieldset><legend>Discussion Threshold</legend><label>Systolic &ge;:</label><input type="number" id="prop-discuss-s" value="${state.discussSystolic}"><label>Diastolic &ge;:</label><input type="number" id="prop-discuss-d" value="${state.discussDiastolic}"></fieldset><fieldset><legend>"Prior to Tx" Checkbox Trigger</legend><label>Systolic &ge;:</label><input type="number" id="prop-checkbox-s" value="${state.checkboxSystolic}"><label>Diastolic &ge;:</label><input type="number" id="prop-checkbox-d" value="${state.checkboxDiastolic}"></fieldset>`; }
            else if (state.type === 'dropdown') { mainPropsHtml = `<label><input type="checkbox" id="prop-required" ${state.required ? 'checked' : ''}> Required</label><hr><fieldset><legend>Dropdown Options</legend><label for="prop-options">(one per line)</label><textarea id="prop-options" rows="6">${state.options.join('\n')}</textarea></fieldset>`; }
            else if (state.type === 'alert' || state.type === 'painscale' || state.type === 'checkbox') { mainPropsHtml = `<label><input type="checkbox" id="prop-required" ${state.required ? 'checked' : ''}> Required</label>`; }

    // --- Formatting Properties  ---

    if (state.type !== 'formatter' && !state.type.startsWith('label-')) { 
        formattingHtml = `<fieldset><legend>Formatting</legend>
            <label><input type="checkbox" id="prop-prefix-newline" ${state.prefixNewline ? 'checked' : ''}> Add Newline Before</label>
            <label><input type="checkbox" id="prop-prefix-tab" ${state.prefixTab ? 'checked' : ''}> Add Tab Before</label>
            <label><input type="checkbox" id="prop-suffix-newline" ${state.suffixNewline ? 'checked' : ''}> Add Newline After</label>
        </fieldset>`; 
    }



            generalPropsHtml = `<fieldset><legend>General Options</legend><label><input type="checkbox" id="prop-hidden" ${state.isHidden ? 'checked' : ''}> Hidden by default</label><label><input type="checkbox" id="prop-no-reset" ${state.doNotReset ? 'checked' : ''}> Do not reset this element</label></fieldset>`;




            // **** START OF REPLACEMENT CODE for width and color ****
            if (state.type !== 'formatter') {
                // Build the color options for the dropdown
                let colorOptions = COLOR_PALETTE.map(color => 
                    `<option value="${color.value}" ${state.fillColor === color.value ? 'selected' : ''}>${color.name}</option>`
                ).join('');

                generalPropsHtml = `
                <fieldset><legend>Sizing & Display</legend>
                    <label>Fill Color: 
                        <select id="prop-fill-color">
                            ${colorOptions}
                        </select>
                    </label>
                    <label style="margin-top: 10px;">Custom Width: <input type="text" id="prop-width" placeholder="e.g., 250px or 48%" value="${state.width || ''}"></label>
                    <hr style="margin:10px 0;">
                    <label><input type="checkbox" id="prop-hidden" ${state.isHidden ? 'checked' : ''}> Hidden by default</label>
                    <label><input type="checkbox" id="prop-no-reset" ${state.doNotReset ? 'checked' : ''}> Do not reset this element's value</label>
                </fieldset>`;
            } else {
                generalPropsHtml = '';
            }
            // **** END OF REPLACEMENT CODE for width and color ****




            body.innerHTML = mainPropsHtml + formattingHtml + generalPropsHtml; if (state.type === 'anesthetic') { const container = document.getElementById('prop-anesthetic-types'); state.anestheticTypes.forEach(type => container.appendChild(createAnestheticTypeRow(type))); document.getElementById('prop-add-anesthetic-type').onclick = () => container.appendChild(createAnestheticTypeRow()); } document.getElementById('properties-modal').style.display = 'block'; document.getElementById('properties-save-btn').onclick = () => saveProperties(element);
        };
        const saveProperties = (element) => {
            const oldState = getElementState(element); const newState = { ...oldState };
            if (newState.type === 'enhanced-textbox') { newState.internalLabel = document.getElementById('prop-internal-label').value; newState.prefixLabel = document.getElementById('prop-prefix-label').value; newState.defaultText = document.getElementById('prop-default-text').value; newState.dropdownOptions = document.getElementById('prop-dropdown-options').value.split('\n').filter(Boolean); if (oldState.content === oldState.defaultText) { newState.content = newState.defaultText; } }
            else if (newState.type === 'anesthetic') { const newTypes = []; document.querySelectorAll('#prop-anesthetic-types .prop-anesthetic-row').forEach(row => { const name = row.querySelector('.prop-anesthetic-name').value.trim(); const mg = parseFloat(row.querySelector('.prop-anesthetic-mg').value); const epi = parseFloat(row.querySelector('.prop-anesthetic-epi').value); if (name && !isNaN(mg) && !isNaN(epi)) { newTypes.push({ name, mg, epi }); } }); newState.anestheticTypes = newTypes; newState.anestheticValues = {}; }

            // **** START OF NEW CODE for tx plan****
            else if (newState.type === 'tx-plan') { saveTxPlanProperties(newState, element); }
            // **** END OF NEW CODE ****
   
            else if (newState.type === 'endo-testing') { newState.endoTests = document.getElementById('prop-endo-tests').value.split('\n').filter(line => line.trim() !== ''); const currentData = JSON.parse(element.dataset.endoData); newState.endoData = { teeth: currentData.teeth, results: {} }; }
            else if (newState.type === 'bloodpressure') { newState.discussSystolic = document.getElementById('prop-discuss-s').value; newState.discussDiastolic = document.getElementById('prop-discuss-d').value; newState.checkboxSystolic = document.getElementById('prop-checkbox-s').value; newState.checkboxDiastolic = document.getElementById('prop-checkbox-d').value; }
            else if (newState.type === 'dropdown') { newState.required = document.getElementById('prop-required').checked; newState.options = document.getElementById('prop-options').value.split('\n').filter(Boolean); newState.selected = newState.options[0] || ''; }
            else if(newState.type === 'painscale' || newState.type === 'alert' || newState.type === 'checkbox') { newState.required = document.getElementById('prop-required').checked; }
            newState.isHidden = document.getElementById('prop-hidden').checked; newState.doNotReset = document.getElementById('prop-no-reset').checked;

            // **** START OF CODE for width****
            const widthInput = document.getElementById('prop-width');
            if (widthInput) {
                newState.width = widthInput.value.trim();
            }
            // **** END OF width CODE ****


            // **** START OF color CODE ****
            const colorSelect = document.getElementById('prop-fill-color');
            if (colorSelect) {
                // If the selected color is the default, save an empty string to keep the JSON clean.
                // Otherwise, save the selected color value.
                newState.fillColor = colorSelect.value === COLOR_PALETTE[0].value ? '' : colorSelect.value;
            }
            // **** END OF color CODE ****




            if (newState.type !== 'formatter' && !newState.type.startsWith('label-')) { const pnl = document.getElementById('prop-prefix-newline'); if (pnl) {newState.prefixNewline = pnl.checked; newState.prefixTab = document.getElementById('prop-prefix-tab').checked; newState.suffixNewline = document.getElementById('prop-suffix-newline').checked;} }
            const newElement = createElement(newState.type, newState); element.replaceWith(newElement); updateLiveOutput(); document.getElementById('properties-modal').style.display = 'none';
        };
        const allergyModal = document.getElementById('allergy-modal'); const allergyListDiv = document.getElementById('allergy-list'); ALLERGY_LIST.forEach(allergy => { allergyListDiv.innerHTML += `<label><input type="checkbox" class="allergy-checkbox" value="${allergy}"> ${allergy}</label>`; }); allergyListDiv.addEventListener('change', e => { if (!e.target.classList.contains('allergy-checkbox')) return; const checkboxes = Array.from(allergyListDiv.querySelectorAll('.allergy-checkbox')); const noneCheckbox = checkboxes.find(cb => cb.value === "None"); if (e.target.value === "None" && e.target.checked) { checkboxes.forEach(cb => { if (cb.value !== "None") cb.checked = false; }); } else if (e.target.value !== "None" && e.target.checked) { if (noneCheckbox.checked) noneCheckbox.checked = false; } }); const openAllergyModal = (element) => { activeElementForEditor = element; const state = getElementState(element); const checkboxes = allergyModal.querySelectorAll('.allergy-checkbox'); checkboxes.forEach(cb => cb.checked = false); const customInput = document.getElementById('custom-allergy-input'); customInput.value = ''; state.alerts.forEach(alert => { const cb = Array.from(checkboxes).find(c => c.value === alert); if (cb) { cb.checked = true; } else if (alert.startsWith('Custom: ')) { customInput.value = alert.substring(8); } }); allergyModal.style.display = 'block'; }; document.getElementById('allergy-save-btn').onclick = () => { if (!activeElementForEditor) return; const selected = []; const checkboxes = allergyModal.querySelectorAll('.allergy-checkbox:checked'); checkboxes.forEach(cb => selected.push(cb.value)); const customValue = document.getElementById('custom-allergy-input').value.trim(); if (customValue) { selected.push(`Custom: ${customValue}`); } if (selected.includes("None")) { activeElementForEditor.dataset.alerts = JSON.stringify(["None"]); } else { activeElementForEditor.dataset.alerts = JSON.stringify(selected.filter(a => a !== "None")); } updateAlertElementUI(activeElementForEditor); updateLiveOutput(); allergyModal.style.display = 'none'; };
        
        // --- Event Listeners (FIXED ORDER) ---
        


// A single, global shortcut handler for Shift+Enter that routes actions based on context.
document.addEventListener('keydown', (event) => {
   // Only proceed if the specific key combination is pressed.
   if (!event.shiftKey || event.key !== 'Enter') {
       return;
   }

   // --- CONTEXT-SENSITIVE ROUTING ---
   const anesModal = document.getElementById('anesthetic-editor-modal');
   const textModal = document.getElementById('textbox-editor-modal');
   const endoModal = document.getElementById('endo-testing-modal');
   const allergyModal = document.getElementById('allergy-modal');
   const txPlanModal = document.getElementById('tx-plan-modal');
   const propsModal = document.getElementById('properties-modal');

   // Check which modal is open
   const isAnesOpen = getComputedStyle(anesModal).display !== 'none';
   const isTextOpen = getComputedStyle(textModal).display !== 'none';
   const isEndoOpen = getComputedStyle(endoModal).display !== 'none';
   const isAllergyOpen = getComputedStyle(allergyModal).display !== 'none';
   const isTxPlanOpen = getComputedStyle(txPlanModal).display !== 'none';
   const isPropsOpen = getComputedStyle(propsModal).display !== 'none';

   const isModalOpen = isAnesOpen || isTextOpen || isEndoOpen || isAllergyOpen || isTxPlanOpen || isPropsOpen;

   // If any modal is open, we need to handle it.
   if (isModalOpen) {
       // Prevent the default browser action (like adding a newline or submitting a form)
       event.preventDefault();
       // Stop the event from propagating further, just in case.
       event.stopPropagation();

       // Now, click the correct save button.
       if (isTextOpen) {
           document.getElementById('textbox-editor-save-btn').click();
       } else if (isAnesOpen) {
           document.getElementById('anesthetic-editor-save-btn').click();
       } else if (isEndoOpen) {
           document.getElementById('endo-testing-save-btn').click();
       } else if (isAllergyOpen) {
           document.getElementById('allergy-save-btn').click();
       } else if (isTxPlanOpen) {
           document.getElementById('tx-plan-save-btn').click();
       } else if (isPropsOpen) {
           document.getElementById('properties-save-btn').click();
       }
   }
   // If NO modal is open, perform the global copy action.
   else {
       event.preventDefault();
       document.getElementById('copy-btn-top').click();

   }
});

   
// New, smarter logic for closing modals by clicking the backdrop
document.querySelectorAll('.modal').forEach(modal => {
    modal.addEventListener('mousedown', (e) => {
        // Close the modal ONLY if the mousedown event is on the backdrop itself
        if (e.target === modal) {
            modal.style.display = 'none';
        }
    });
});

// Separate listener for closing the context menu
        // **** START OF MODIFIED CODE to include tx plan copy/paste****
        window.addEventListener('mousedown', (e) => {
            const contextMenu = document.getElementById('context-menu');
            const selectionMenu = document.getElementById('text-selection-menu');
            
            if (!e.target.closest('#context-menu') && !e.target.closest('.draggable-element')) {
                contextMenu.style.display = 'none';
            }

        // ****this code is erroring with style in console            if (!e.target.closest('#text-selection-menu')) {
         // ****               selectionMenu.style.display = 'none';
          // ****          }

        });
        // **** END OF MODIFIED CODE ****


        document.getElementById('ctx-delete').onclick = () => { if (activeElementForEditor) { activeElementForEditor.remove(); updateLiveOutput(); } };
        document.getElementById('ctx-properties').onclick = () => { if (activeElementForEditor) openPropertiesModal(activeElementForEditor); };
        document.querySelectorAll('.add-element-btn').forEach(btn => btn.onclick = e => { currentSectionToAdd = e.target.dataset.section; document.getElementById('add-element-modal').style.display = 'block'; });
        document.querySelectorAll('.close-btn').forEach(btn => btn.onclick = e => document.getElementById(e.target.dataset.modalId).style.display = 'none');
        document.querySelectorAll('.element-type').forEach(el => el.onclick = e => { const type = e.currentTarget.dataset.type; const dropzone = document.querySelector(`#${currentSectionToAdd} .dropzone`); if(dropzone) { dropzone.appendChild(createElement(type)); } updateLiveOutput(); document.getElementById('add-element-modal').style.display = 'none'; });
        document.querySelectorAll('.dropzone').forEach(zone => zone.addEventListener('dragover', e => { e.preventDefault(); const draggingEl = document.querySelector('.draggable-element.dragging'); if (!draggingEl) return; const afterElement = [...zone.querySelectorAll('.draggable-element:not(.dragging)')].reduce((closest, child) => { const box = child.getBoundingClientRect(); const offset = e.clientY - box.top - box.height / 2; return (offset < 0 && offset > closest.offset) ? { offset: offset, element: child } : closest; }, { offset: Number.NEGATIVE_INFINITY }).element; if (afterElement == null) zone.appendChild(draggingEl); else zone.insertBefore(draggingEl, afterElement); }));
 


// **** START OF CODE for copyAction with evaluation****

        const copyAction = () => {
            const noteText = liveOutput.value;
            
            // 1. Run the evaluation on the current note text.
            const suggestions = evaluateNote(noteText);

            // 2. Build the confirmation message.
            let alertMessage = "Note Copied!";
            if (suggestions.length > 0) {
                // If there are suggestions, add them to the message on new lines.
                alertMessage += "\n\n--- Suggestions ---\n" + suggestions.join('\n');
            }

            // 3. Copy the text to the clipboard and show the confirmation message.
            navigator.clipboard.writeText(noteText).then(() => {
                alert(alertMessage);
            });
        };

        // **** END OF  CODE for copyAction with evaluation ****



document.getElementById('copy-btn-top').addEventListener('click', copyAction); document.getElementById('copy-btn-bottom').addEventListener('click', copyAction);





        const fileInput = document.createElement('input'); fileInput.type = 'file'; fileInput.accept = '.json'; fileInput.style.display = 'none'; document.body.appendChild(fileInput);
        document.getElementById('import-btn').addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => { const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (re) => { loadJsonData(re.target.result); }; reader.readAsText(file); e.target.value = ''; });
        document.getElementById('export-btn').onclick = () => { const state = {}; SECTIONS.forEach(id => { state[id] = []; document.querySelector(`.dropzone[data-section-id="${id}"]`).querySelectorAll('.draggable-element').forEach(el => state[id].push(getElementState(el))); }); const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'dental-note-template.json'; a.click(); URL.revokeObjectURL(a.href); };
        document.getElementById('reset-btn').addEventListener('click', resetValues);
document.getElementById('full-reset-btn').addEventListener('click', fullReset);
        document.getElementById('view-hidden-toggle').addEventListener('change', (e) => { if (e.target.checked) { document.body.classList.add('show-hidden-elements'); } else { document.body.classList.remove('show-hidden-elements'); }});
        
// **** START OF NEW CODE for lock toggle****
document.getElementById('lock-layout-toggle').addEventListener('change', (e) => {
    if (e.target.checked) {
        document.body.classList.add('layout-locked');
        // Make all elements non-draggable
        document.querySelectorAll('.draggable-element').forEach(el => el.setAttribute('draggable', 'false'));
    } else {
        document.body.classList.remove('layout-locked');
        // Make all elements draggable again
        document.querySelectorAll('.draggable-element').forEach(el => el.setAttribute('draggable', 'true'));
    }
});
// **** END OF NEW CODE ****



        // --- Initial Setup ---
        const loadJsonData = (jsonString, isStartup = false, isFromFileImport = false) => {
            try {
                const state = JSON.parse(jsonString);
                
                // If this is a new file import, it becomes the new template AND we must clear the old session.
                if (isFromFileImport) {
                    console.log("New file imported. Clearing old localStorage session.");
                    localStorage.removeItem('dentalNoteMakerSession');
                    lastLoadedState = JSON.parse(JSON.stringify(state)); // This becomes the new "source of truth" for reset.
                }
                
                renderState(state, isFromFileImport);

                if (!isStartup) {
                    alert('Template loaded successfully!');
                }
                return true;
            } catch (err) {
                console.error("JSON Parse Error:", err);
                if (!isStartup) { alert('Error: Invalid JSON data.'); }
                return false;
            }
        };

        const renderState = (state, isNewTemplate = false) => {
            document.querySelectorAll('.dropzone').forEach(zone => zone.innerHTML = '');
            
            // If we are loading a NEW template, we must build the lastLoadedState memory.
            // If we are just restoring a session, lastLoadedState is already in memory from the initial load.
            if (isNewTemplate) {
                lastLoadedState = {}; 
                SECTIONS.forEach((sectionId) => {
                    const elements = state[sectionId] || [];
                    if (!lastLoadedState[sectionId]) lastLoadedState[sectionId] = [];
                    elements.forEach((item, itemIndex) => {
                        lastLoadedState[sectionId][itemIndex] = JSON.parse(JSON.stringify(item));
                    });
                });
            }

            SECTIONS.forEach((sectionId, secIndex) => {
                const zone = document.querySelector(`.dropzone[data-section-id="${sectionId}"]`);
                const elements = state[sectionId] || [];
                if (zone && Array.isArray(elements)) {
                    elements.forEach((item, itemIndex) => {
                        item.originalId = `${secIndex}-${itemIndex}`;
                        zone.appendChild(createElement(item.type, item));
                    });
                }
            });
            
            updateLiveOutput();
            const lockToggle = document.getElementById('lock-layout-toggle');
            if (lockToggle.checked) {
                lockToggle.dispatchEvent(new Event('change'));
            }
        };

        // --- STARTUP CONFIGURATION CASCADE ---
        const savedSession = localStorage.getItem('dentalNoteMakerSession');
        
        // This function defines the default loading sequence.
        function loadDefaults() {
            // Priority 2: Try to load from the embedded JSON data.
            const defaultJsonText = document.getElementById('default-json-data').textContent;
            if (defaultJsonText && defaultJsonText.trim().length > 2) {
                console.log("No session found. Loading from embedded JSON data.");
                loadJsonData(defaultJsonText, true, true); // Treat as a new template
            } else {
                // Priority 3: If no embedded JSON, start blank.
                console.log("No session or embedded JSON. Starting with a blank slate.");
                renderState({});
            }
        }

        // Run the cascade
        if (savedSession) {
            // Priority 1: A previous session exists. We need to load both the session AND its underlying template.
            console.log("Loading from saved browser session.");
            const sessionState = JSON.parse(savedSession);
            // First, load the template that this session was based on.
            const defaultJsonText = document.getElementById('default-json-data').textContent;
            if (defaultJsonText && defaultJsonText.trim().length > 2) {
                loadJsonData(defaultJsonText, true, true); // Load template but don't show UI yet
            } else {
                renderState({}, true); // Prepare a blank template
            }
            // Now, render the user's actual saved work over the top of it.
            renderState(sessionState, false); // Render session state, but don't overwrite the template memory.
        } else {
            // No session found, proceed to the normal default loading sequence.
            loadDefaults();
        }
 
   
    });
    </script>






<center><br><h6>-NAVMED 6600/13 JSON default-<br>
Questions/Support? <a href="mailto:mark.g.horning.civ@health.mil">MG Horning</a></h6></center>

<script>
// ===================================================================================
//
//   --- DENTAL SUGGESTER SCRIPT (PORTABLE VERSION) ---
//
//   Instructions:
//   1. Ensure the <textarea> or <input> you want to target in your HTML has a unique `id`.
//   2. Copy this entire <script> block and paste it just before the closing </body> tag
//      in your existing HTML file.
//   3. Change the `targetTextboxId` value below to match the `id` of your textbox.
//
// ===================================================================================

(function() {
    // ============================= CONFIGURATION ===================================
    //  !!! IMPORTANT !!! 
    //  Change 'myNotesTextbox' to the actual ID of your textbox element.
    const targetTextboxId = 'textbox-editor-textarea'; 
    // ===============================================================================






    // ===================================================================================
    //   --- LIBRARY OF TERMS --- (Dictionary is collapsed for brevity) (add or subtract terms as necessary - MG Horning initial list vJULY 2025
    // ===================================================================================
const dictionary = ["Abrasion", "Abscess", "Abscess (Periapical)", "Abscess (Periodontal)", "Abutment", "Acanthosis", "Access Cavity", "Acid Etch", "Acrylic Resin", "Actinic Cheilitis", "Acute Apical Abscess", "Acute Pulpitis", "Adenoid Cystic Carcinoma", "Adenomatoid Odontogenic Tumor", "Adenopathy", "Airway Obstruction", "Albright Syndrome", "Alginate", "Allergic Reaction", "Allograft", "Alloplast", "Alveolar Bone", "Alveolar Crest", "Alveolar Osteitis (Dry Socket)", "Alveolar Ridge", "Alveoloplasty", "Amalgam", "Amalgam Carrier", "Amalgam Well", "Ameloblastic Carcinoma", "Ameloblastic Fibro-odontoma", "Ameloblastic Fibroma", "Ameloblastoma", "Amelogenesis Imperfecta", "Anaphylaxis", "Aneurysmal Bone Cyst", "Angular Cheilitis", "Angular Defect", "Ankyloglossia", "Ankylosis", "Anodontia", "Apex Locator", "Apexification", "Apexogenesis", "Aphthous Ulcer", "Aphthous Ulcer (Canker Sore)", "Apical Foramen", "Apical Periodontitis", "Apical Scar", "Apicoectomy", "Articaine", "Articulating Paper", "Aspirator Tip", "Asymptomatic", "Attrition", "Atypical Odontalgia", "Autograft", "BOP (Bleeding on Probing)", "Barbed Broach", "Barrier Membrane", "Basal Cell Carcinoma", "Base", "Benign", "Benign Migratory Glossitis", "Bifid Condyle", "Bifid Tongue", "Bilateral", "Biopsy", "Biopsy (Excisional)", "Biopsy (Incisional)", "Bite Registration", "Black Hairy Tongue", "Blade Elevator", "Bleaching (Internal)", "Bleb", "Block Graft", "Bone Density", "Bone File", "Bone Graft", "Bone Loss", "Bone Marrow Space", "Bone Scraper", "Bone Screw", "Bonding Agent", "Bruxism", "Buccal Exostosis", "Buccinator Muscle", "Bulla", "Burnisher", "C/P (Complete/Partial Denture)", "CAL (Clinical Attachment Loss)", "CBCT (Cone Beam Computed Tomography)", "CEJ (Cementoenamel Junction)", "Calcifying Epithelial Odontogenic Tumor", "Calcifying Odontogenic Cyst", "Calcium Hydroxide", "Calculus", "Calculus Bridge", "Candidiasis", "Candidiasis (Thrush)", "Canine Impaction", "Canine Substitution", "Canthotomy", "Caries", "Caries (Incipient)", "Caries (Occlusal)", "Caries (Proximal)", "Caries (Rampant)", "Caries (Root)", "Carver", "Cast Post", "Cavernous Hemangioma", "Cellulitis", "Cement", "Cemental Dysplasia", "Cemental Tear", "Cementoblastoma", "Cemento-ossifying Fibroma", "Central Giant Cell Granuloma", "Ceramic Fracture", "Cervical Burnout", "Chelating Agent", "Cherubism", "Chronic Apical Abscess", "Chronic Hyperplastic Pulpitis", "Chronic Periodontitis", "Chronic Pulpitis", "Circumferential Bone Loss", "Circumscribed", "Cleft Lip", "Cleft Lip Repair", "Cleft Palate", "Cleft Palate Repair", "Cleidocranial Dysplasia", "Closed Reduction", "Cold Test", "Complex Odontoma", "Composite Resin", "Compound Odontoma", "Concrescence", "Condenser", "Condensing Osteitis", "Condylar Aplasia", "Condylar Hyperplasia", "Condylar Hypoplasia", "Congenital", "Connective Tissue Graft", "Contact Point", "Coping", "Core Buildup", "Coronectomy", "Coronoid Hyperplasia", "Corrugated", "Corticated Border", "Cotton Wool Appearance", "Cowhorn Forceps (#23)", "Cracked Tooth Syndrome", "Cratered", "Crepitus", "Crestal Lamina Dura", "Crossbite", "Crown Fracture", "Crown-down Technique", "Crown-to-Root Ratio", "Cryer Elevator", "Curettage", "Curing Light", "Cyst", "Cystic", "Debridement", "Decortication", "Dehiscence", "Dense Bone Island", "Dens Evaginatus", "Dens Invaginatus (Dens in Dente)", "Dental Dam", "Dental Fluorosis", "Dental Lamina", "Dental Stone", "Dentin Dysplasia", "Dentinogenesis Imperfecta", "Dentigerous Cyst", "Denture Adhesive", "Denture Base", "Denture Stomatitis", "Denture Teeth", "Denture-induced Fibrous Hyperplasia", "Depressor Anguli Oris Muscle", "Depressor Labii Inferioris Muscle", "Desensitizer", "Desquamative Gingivitis", "Developmental Anomaly", "Deviation", "Deviation (Mandibular)", "Diastema", "Deviation (Nasal Septum)", "Diastema", "Die Stone", "Diffuse", "Diffuse Border", "Diffuse Sclerosing Osteomyelitis", "Digastric Muscle (Anterior Belly)", "Digastric Muscle (Posterior Belly)", "Dilaceration", "Disc Displacement", "Dislocation", "Distoangular Impaction", "Drain Placement", "Drifting", "Drill", "Dycal", "Dysphagia (Difficulty Swallowing)", "Dysphonia (Hoarseness)", "Dysplasia", "E-max (Lithium Disilicate)", "E/O (Extraoral)", "EPT (Electric Pulp Test)", "Eagle Syndrome", "Ectodermal Dysplasia", "Ectopic Eruption", "Edematous", "Edentulous", "Elastomeric Impression Material", "Elevation", "Elevator", "Enamel Hypoplasia", "Enamel Pearl", "Endodontic Explorer", "Endodontic File", "Endodontic Sealer", "Endophytic", "Enostosis", "Enucleation", "Epinephrine", "Epulis Fissuratum", "Erosion", "Eruption Cyst", "Erythema Multiforme", "Erythematous", "Erythroplakia", "Etchant", "Excisional Biopsy", "Excision", "Exophytic", "Exostosis", "External Resorption", "Extraction", "Extrusion", "FGC (Full Gold Crown)", "FGG (Free Gingival Graft)", "FMX (Full Mouth X-rays)", "Fenestration", "Fiber Post", "Fibroma", "Fibrous", "Fibrous Dysplasia", "Fine Needle Aspiration (FNA)", "Finishing Strip", "Fissured", "Fissured Tongue", "Fistula", "Fistula / Sinus Tract", "Flap Advancement", "Flap Design", "Flap Reflection", "Flap Retraction", "Florid Cemento-osseous Dysplasia", "Flowable Composite", "Fluctuant", "Fluoride", "Fluorosis", "Focal Cemento-osseous Dysplasia", "Focal Sclerosing Osteomyelitis", "Follicular Cyst", "Forceps", "Forceps (#150)", "Forceps (#151)", "Fordyce Granules", "Foreign Body Reaction", "Fremitus", "Frenectomy", "Frenectomy (Lingual/Labial)", "Friable", "Frictional Keratosis", "Full Bony Impaction", "Full Thickness Flap", "Furcation Arrow", "Furcation Involvement", "Furcation Involvement (Class I)", "Furcation Involvement (Class II)", "Furcation Involvement (Class III)", "Furcation Involvement (Class IV)", "Fusion", "GBR (Guided Bone Regeneration)", "GTR (Guided Tissue Regeneration)", "Gardner Syndrome", "Garre's Osteomyelitis", "Gates-Glidden Drill", "Gemination", "Genioglossus Muscle", "Geniohyoid Muscle", "Geographic Tongue", "Geographic Tongue (Benign Migratory Glossitis)", "Ghost Teeth", "Giant Cell Fibroma", "Gingival Abscess", "Gingival Cleft", "Gingival Enlargement", "Gingival Hyperplasia", "Gingival Recession", "Gingivectomy", "Gingivitis", "Gingivoplasty", "Glandular Odontogenic Cyst", "Glass Ionomer Cement", "Glossectomy", "Goiter", "Gold Alloy", "Gorlin Cyst", "Gorlin-Goltz Syndrome", "Gow-Gates Block", "Graft", "Granular Cell Tumor", "Granulation Tissue", "Ground-glass Appearance", "Guided Bone Regeneration", "Guided Tissue Regeneration", "Gutta-percha", "Hairy Leukoplakia", "Hairy Tongue", "Hamular Notch", "Hand-Schuller-Christian Disease", "Hard Tissue", "Healing Abutment", "Heat Test", "Hemangioma", "Hemisection", "Hemodent", "Hemostasis", "Hemostat", "Hereditary", "Herpangina", "Herpes Simplex Virus", "Herpetic Gingivostomatitis", "High-speed Handpiece", "Histoplasmosis", "Homogeneous", "Horizontal Bone Loss", "Horizontal Impaction", "Hyoglossus Muscle", "Hypercementosis", "Hyperdontia", "Hyperdontia (Supernumerary Teeth)", "Hyperkeratosis", "Hyperkeratotic", "Hyperplasia", "Hypodontia", "I/O (Intraoral)", "IANB (Inferior Alveolar Nerve Block)", "IRM (Intermediate Restorative Material)", "Idiopathic Osteosclerosis", "Impacted Tooth", "Implant Fixture", "Implant Placement", "Impression Compound", "Impression Tray", "Incipient Caries", "Incisional Biopsy", "Incision", "Incision and Drainage", "Incisive Canal Cyst", "Indurated", "Indirect Pulp Cap", "Infiltration Anesthesia", "Inflammation", "Inlay", "Instrumentation", "Internal Resorption", "Intermaxillary Fixation", "Interproximal Caries", "Intrabony Defect", "Intracanal Medicament", "Intrusion", "Irrigation", "Irreversible Pulpitis", "Irritation Fibroma", "Kaposi's Sarcoma", "Keratinized Gingiva", "Keratocystic Odontogenic Tumor (KCOT)", "Keratosis", "Langerhans Cell Histiocytosis", "Laryngectomy", "Laryngoscopy", "Lateral Cephalogram", "Lateral Periodontal Cyst", "Lateral Pterygoid Muscle", "Le Fort I Fracture", "Le Fort I/II/III Osteotomy", "Le Fort II Fracture", "Le Fort III Fracture", "Leukoplakia", "Leukoplakic", "Levator Anguli Oris Muscle", "Lichen Planus", "Lichen Planus (Oral)", "Lichenoid Mucositis", "Lidocaine", "Liner", "Lingual Nerve", "Lingual Thyroid", "Lingual Varicosities", "Lipoma", "Local Anesthesia", "Localized", "Loss of Lamina Dura", "Low-speed Handpiece", "Ludwig's Angina", "Lupus Erythematosus", "Luxation", "Lymphadenopathy", "Lymphangioma", "Lymphoepithelial Cyst", "MOD (Mesio-Occluso-Distal)", "MTA (Mineral Trioxide Aggregate)", "Macrodontia", "Macule", "Malignant", "Mallet", "Malocclusion", "Mandibular Canal", "Mandibular Fracture", "Mandibular Tori", "Marsupialization", "Masseter Muscle", "Matrix Band", "Maxillary Sinus Lift", "Maxillectomy", "Medial Pterygoid Muscle", "Median Palatal Cyst", "Median Rhomboid Glossitis", "Melanoma", "Melanotic Neuroectodermal Tumor of Infancy", "Membrane", "Mental Foramen", "Mentalis Muscle", "Mepivacaine", "Mesioangular Impaction", "Metal-ceramic Crown", "Metastatic Disease", "Micro-hybrid Composite", "Microdontia", "Mobility (Class I)", "Mobility (Class II)", "Mobility (Class III)", "Morsicatio buccarum", "Moth-eaten Appearance", "Mottled", "Mucocele", "Mucoepidermoid Carcinoma", "Mucogingival Defect", "Multifocal", "Multilocular", "Multilocular Radiolucency", "Multiple Myeloma", "Mylohyoid Muscle", "Mylohyoid Ridge", "Myxoma", "NICO (Neuralgia-Inducing Cavitational Osteonecrosis)", "NUG (Necrotizing Ulcerative Gingivitis)", "NUP (Necrotizing Ulcerative Periodontitis)", "Nanofill Composite", "Nasolabial Cyst", "Nasopalatine Duct Cyst", "Neck Dissection (Radical/Modified)", "Necrosis", "Necrotizing Sialometaplasia", "Needle Holder", "Neoplasm", "Nerve Block", "Nerve Repositioning", "Neuralgia", "Neurilemmoma", "Neurofibroma", "Nevoid Basal Cell Carcinoma Syndrome", "Nicotine Keratosis", "Nodule", "Non-vital Tooth", "OCS (Oral Cancer Screening)", "Obturation", "Occlusal Caries", "Occlusal Splint", "Occlusal Trauma", "Odontogenic Keratocyst", "Odontogenic Myxoma", "Odontoma", "Odontotomy", "Odynophagia (Painful Swallowing)", "Oligodontia", "Onlay", "Onion-skin Appearance", "Open Apex", "Open Bite", "Open Contact", "Open Reduction", "Operculum", "Oral Hairy Leukoplakia", "Oral Submucous Fibrosis", "Orbicularis Oris Muscle", "Orthokeratinized Odontogenic Cyst", "Osseointegration", "Osseous Recontouring", "Osseous Surgery", "Ossifying Fibroma", "Osteitis Deformans", "Osteoblastoma", "Osteochondroma", "Osteogenesis Imperfecta", "Osteoma", "Osteomyelitis", "Osteonecrosis of the Jaw (ONJ)", "Osteopetrosis", "Osteoporosis", "Osteoradionecrosis", "Osteosarcoma", "Osteotomy", "Overbite", "Overhanging Restoration", "Overjet", "PA (Periapical Radiograph)", "PD (Probing Depth)", "PDL (Periodontal Ligament)", "PFM (Porcelain Fused to Metal)", "PVS (Polyvinyl Siloxane)", "Packable Composite", "Paget's Disease", "Palatal Expansion", "Palatal Torus", "Palatoglossus Muscle", "Palpation Test", "Panoramic Radiograph", "Paper Point", "Papillary", "Papilloma", "Papule", "Parotidectomy", "Parulis", "Partially Erupted", "Partial Bony Impaction", "Patch", "Pathologic Fracture", "Pedunculated", "Pell & Gregory Classification", "Pemphigoid", "Pemphigus Vulgaris", "Percussion Test", "Perforation Repair", "Peri-implantitis", "Periapical Cemental Dysplasia", "Periapical Cyst", "Periapical Granuloma", "Periapical Rarefying Osteitis", "Periapical Sclerosing Osteitis", "Pericoronitis", "Periodontal Abscess", "Periodontal Pocket", "Periodontitis", "Periodontitis (Aggressive)", "Periodontitis (Chronic)", "Periosteal Elevator", "Periosteum", "Peripheral Giant Cell Granuloma", "Peripheral Ossifying Fibroma", "Periotome", "Pesso Reamer", "Pharyngitis", "Phoenix Abscess", "Pindborg Tumor", "Plaque", "Plate and Screw Fixation", "Platysma Muscle", "Pleomorphic Adenoma", "Plunger Cusp", "Pneumatization", "Polycarbonate Crown", "Polyether", "Polypoid", "Polysulfide", "Polyvinyl Siloxane (PVS)", "Porcelain", "Porcelain-fused-to-metal (PFM)", "Post-and-Core", "Posterior Crossbite", "Potts Elevator", "Pre-prosthetic Surgery", "Prefabricated Post", "Pregnancy Granuloma", "Premalignant", "Primary Closure", "Primordial Cyst", "Proliferative Periostitis", "Provisional Restoration", "Pseudocyst", "Pulp Attrition", "Pulp Calcification", "Pulp Cap", "Pulp Chamber", "Pulp Exposure", "Pulp Necrosis", "Pulp Polyp", "Pulp Polyp (Chronic Hyperplastic Pulpitis)", "Pulp Stone", "Pulp Test", "Pulpitis", "Punched-out Radiolucencies", "Pustule", "Pyogenic Granuloma", "RCT (Root Canal Therapy)", "RMGI (Resin-Modified Glass Ionomer)", "Radiation Caries", "Radicular Cyst", "Radio-dense", "Radiograph", "Radiographic Calculus", "Radiolucent", "Radiopaque", "Ranula", "Recurrent Aphthous Stomatitis", "Recurrent Caries", "Regional Odontodysplasia", "Reline", "Resin Cement", "Residual Cyst", "Residual Ridge", "Resorption", "Retraction Cord", "Retreatment", "Reversible Pulpitis", "Rhabdomyosarcoma", "Rhinoplasty", "Ridge Augmentation", "Ridge Preservation", "Ridge Split", "Risorius Muscle", "Rongeur", "Root Amputation", "Root Canal", "Root Caries", "Root Concavity", "Root Fracture", "Root Planing", "Root Proximity", "Root Resection", "Root Submergence", "Root Trunk", "Rubber Dam", "Runner's Caries", "SRP (Scaling and Root Planing)", "Saddle", "Schwannoma", "Scleroderma", "Sclerotic Bone", "Secondary Caries", "Self-etch Primer", "Sequestrum", "Sessile", "Sialadenitis", "Sialendoscopy", "Sialolith", "Sialolithiasis", "Sialolithiasis (Salivary Stone)", "Silver Diamine Fluoride", "Sinus Tract", "Sjogren Syndrome", "Sleep Apnea (Obstructive)", "Slow-speed Handpiece", "Socket Sclerosis", "Soft Tissue", "Soft Tissue Impaction", "Spatula", "Speckled", "Spongy", "Squamous Cell Carcinoma", "Stafne Bone Defect", "Stainless Steel Crown", "Step-back Technique", "Sternocleidomastoid Muscle", "Stevens-Johnson Syndrome", "Stomatitis", "Styloglossus Muscle", "Stylohyoid Muscle", "Subluxation", "Subpontic Osseous Hyperplasia", "Sunburst Appearance", "Supernumerary Root", "Supernumerary Tooth", "Suprabony Pocket", "Surveyor", "Symptomatic", "Syphilis", "TMJ (Temporomandibular Joint)", "Taurodontism", "Temporalis Muscle", "Temporary Cement", "Temporary Crown", "Tetracycline Staining", "Tetracycline Staining", "Thalassemia", "Thyroidectomy", "Tipping", "Tobacco Keratosis", "Tongue Thrust", "Tonsillectomy", "Tonsillitis", "Torus Mandibularis", "Torus Palatinus", "Total-etch", "Tracheostomy", "Transillumination", "Trapezius Muscle", "Traumatic Bone Cyst", "Traumatic Neuroma", "Trigeminal Neuralgia", "Trismus", "Trituration", "Tuberculosis", "Turner's Hypoplasia", "Ulcer", "Ulcerated", "Unicystic Ameloblastoma", "Unifocal", "Unilateral", "Unilocular Radiolucency", "Unerupted Tooth", "Uvulopalatopharyngoplasty (UPPP)", "Varnish", "Veneer", "Verrucous", "Verrucous Carcinoma", "Vertical Bone Loss", "Vertical Dimension", "Vertical Fracture", "Vertical Impaction", "Vertigo", "Vesicle", "WNL (Within Normal Limits)", "Wedge", "Weeping Canal", "White Sponge Nevus", "Widened PDL Space", "Xerostomia (Dry Mouth)", "ZOE (Zinc Oxide Eugenol)", "Zinc Oxide Eugenol (ZOE)", "Zinc Phosphate Cement", "Zirconia", "Zygomaticus Major Muscle", "Zygomaticus Minor Muscle"];

    // ===================================================================================
    //   --- APPLICATION LOGIC (v2.0) mgh ---
    // ===================================================================================




    // **** START OF  CODE: Auto-Correct Function with handleinput and attacheventlisteners****
   

// This is the new, combined function that handles BOTH suggestions and auto-correct.
// **** START OF REPLACEMENT for handleCombinedInput ****

const handleCombinedInput = (event) => {
    const textarea = event.target;
    const fullText = textarea.value;
    const cursorPos = textarea.selectionStart;
    const textBeforeCursor = fullText.substring(0, cursorPos);
    const lastChar = textBeforeCursor.slice(-1);

    // --- 1. Auto-Correct Logic ---
    if (lastChar === ' ' || lastChar === '.' || lastChar === ',') {
        const lastSpaceIndex = textBeforeCursor.lastIndexOf(' ', cursorPos - 2);
        const lastWord = textBeforeCursor.substring(lastSpaceIndex + 1).trim();

        const match = lastWord.match(/^(\d+)(?![mM]{2}$)([a-zA-Z]+)$/);
        
        if (match) {
            const toothNumber = match[1];
            const surfaceLetters = match[2];

            console.log(`Auto-Correct: Detected tooth shorthand "${lastWord}"`);

            const correctedShorthand = `(${surfaceLetters.toUpperCase()})`;
            const replacement = `#${toothNumber}${correctedShorthand},`;

            console.log(`Auto-Correct: Formatting to "${replacement}"`);
            
            const textAfterCursor = fullText.substring(cursorPos);
            const newText = textBeforeCursor.substring(0, lastSpaceIndex + 1) + replacement + fullText.substring(cursorPos - 1);

            textarea.value = newText;
            
            const newCursorPos = lastSpaceIndex + 1 + replacement.length + 1;
            textarea.setSelectionRange(newCursorPos, newCursorPos);
            
            hideSuggestions();
            return; 
        }
    }

    // --- 2. Auto-Suggester Logic (runs if auto-correct did not) ---
    const lastSpaceIndexForSuggest = textBeforeCursor.lastIndexOf(' ');
    const currentWordForSuggest = textBeforeCursor.substring(lastSpaceIndexForSuggest + 1).toLowerCase();

    if (!currentWordForSuggest) {
        hideSuggestions();
        return;
    }
    
    // **** THIS IS THE FIX ****
    // The 'dictionary' constant is already available in this script's scope.
    // We don't need to look for it on the window object.
    const filteredTerms = dictionary.filter(term => term.toLowerCase().startsWith(currentWordForSuggest));
    displaySuggestions(filteredTerms, currentWordForSuggest);
};

// **** END OF REPLACEMENT for handleCombinedInput ****

function attachEventListeners() {
    // We now attach ONLY our single, combined handler to the input event.
    textInput.addEventListener('input', handleCombinedInput); 
    
    // The other listeners remain the same.
    textInput.addEventListener('keydown', handleKeyDown);
    document.addEventListener('click', handleGlobalClick);
    window.addEventListener('scroll', hideSuggestions, true);
    window.addEventListener('resize', hideSuggestions);
}

// (The handleAutoCorrect function is no longer needed as a separate function)
// const handleInput = () => { ... }; // The old handleInput is also no longer needed





    // **** END OF AUTOCORRECT CODE ****






    let textInput = null;
    let suggestionsContainer = null;
    const suggestionsId = 'dental-suggester-list-999';

    function init() {
        textInput = document.getElementById(targetTextboxId);
        if (!textInput) {
            console.error(`Dental Suggester Error: Textbox with ID "${targetTextboxId}" not found.`);
            return;
        }
        injectStyles();
        createSuggestionsContainer();
        attachEventListeners();
        console.log(`Dental Suggester initialized successfully on #${targetTextboxId}.`);
    }

    function injectStyles() {
        const style = document.createElement('style');
        // --- KEY CHANGE ---
        // We set position: fixed to position relative to the viewport.
        // We remove the 'width' property because JS will now set it dynamically.
        style.innerHTML = `
            #${suggestionsId} {
                list-style-type: none; padding: 0; margin: 0;
                border: 1px solid #ddd;
                border-radius: 5px;
                max-height: 300px; overflow-y: auto;
                position: fixed; /* Position relative to the window, not a parent */
                background-color: white;
                z-index: 10000;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                display: none;
            }
            #${suggestionsId} li {
                padding: 10px 12px; cursor: pointer;
                background-color: #fff; border-bottom: 1px solid #f0f0f0;
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                font-size: 14px;
            }
            #${suggestionsId} li:last-child { border-bottom: none; }
            #${suggestionsId} li:hover, #${suggestionsId} li.active { background-color: #e9e9e9; }
            #${suggestionsId} li strong { font-weight: bold; }
        `;
        document.head.appendChild(style);
    }

    function createSuggestionsContainer() {
        const container = document.createElement('ul');
        container.id = suggestionsId;
        // Append to the body to ensure it's not trapped inside a misbehaving container
        document.body.appendChild(container);
        suggestionsContainer = container;
    }



    function displaySuggestions(suggestions, query) {
        if (suggestions.length === 0) {
            hideSuggestions();
            return;
        }
        
        // --- KEY CHANGE: JAVASCRIPT POSITIONING ---
        // Get the exact position and size of the textbox
        const rect = textInput.getBoundingClientRect();
        
        // Position the suggestions box right below the textbox
        suggestionsContainer.style.left = `${rect.left}px`;
        suggestionsContainer.style.top = `${rect.bottom}px`;
        suggestionsContainer.style.width = `${rect.width}px`; // Match the width

        suggestionsContainer.innerHTML = '';
        suggestionsContainer.style.display = 'block';

        suggestions.slice(0, 50).forEach(term => {
            const listItem = document.createElement('li');
            listItem.setAttribute('data-term', term);
            const boldPart = term.substring(0, query.length);
            const restPart = term.substring(query.length);
            listItem.innerHTML = `<strong>${boldPart}</strong>${restPart}`;
            listItem.addEventListener('mousedown', (e) => {
                e.preventDefault();
                selectTerm(term);
            });
            suggestionsContainer.appendChild(listItem);
        });
    }

    // Unchanged functions (handleInput, handleKeyDown, etc.) are below

    const handleKeyDown = (e) => { /* ... same as before ... */ if (suggestionsContainer.style.display === 'none') return; const suggestions = suggestionsContainer.querySelectorAll('li'); if (suggestions.length === 0) return; let activeIndex = -1; suggestions.forEach((s, index) => { if (s.classList.contains('active')) activeIndex = index; }); if (e.key === 'ArrowDown') { e.preventDefault(); if (activeIndex < suggestions.length - 1) { if (activeIndex > -1) suggestions[activeIndex].classList.remove('active'); suggestions[activeIndex + 1].classList.add('active'); } } else if (e.key === 'ArrowUp') { e.preventDefault(); if (activeIndex > 0) { suggestions[activeIndex].classList.remove('active'); suggestions[activeIndex - 1].classList.add('active'); } } else if (e.key === 'Enter' && activeIndex > -1) { e.preventDefault(); selectTerm(suggestions[activeIndex].getAttribute('data-term')); } else if (e.key === 'Escape' || e.key === 'Tab') { hideSuggestions(); } };
    const handleGlobalClick = (event) => { /* ... same as before ... */ if (!textInput.contains(event.target) && !suggestionsContainer.contains(event.target)) { hideSuggestions(); } };
    function selectTerm(term) { /* ... same as before ... */ const fullText = textInput.value; const cursorPos = textInput.selectionStart; const textBeforeCursor = fullText.substring(0, cursorPos); const textAfterCursor = fullText.substring(cursorPos); const lastSpaceIndex = textBeforeCursor.lastIndexOf(' '); const baseText = textBeforeCursor.substring(0, lastSpaceIndex + 1); textInput.value = baseText + term + ' ' + textAfterCursor; hideSuggestions(); textInput.focus(); const newCursorPos = (baseText + term + ' ').length; textInput.setSelectionRange(newCursorPos, newCursorPos); }
    function hideSuggestions() { if (suggestionsContainer) { suggestionsContainer.style.display = 'none'; } }
    
    document.addEventListener('DOMContentLoaded', init);
})();




    // **** CHARTING CODE ****



        const dentalChartSVG = document.getElementById('dentalChart');
        const teethData = {}; // Stores references to SVG path elements for each tooth's surfaces

        // Tooth positions (Universal Numbering System)
        const toothPositions = {
            // Upper Right (1-8)
            1: { x: 50, y: 100, isUpper: true, quadrant: 1 },
            2: { x: 100, y: 100, isUpper: true, quadrant: 1 },
            3: { x: 150, y: 100, isUpper: true, quadrant: 1 },
            4: { x: 200, y: 100, isUpper: true, quadrant: 1 },
            5: { x: 250, y: 100, isUpper: true, quadrant: 1 },
            6: { x: 300, y: 100, isUpper: true, quadrant: 1 },
            7: { x: 350, y: 100, isUpper: true, quadrant: 1 },
            8: { x: 400, y: 100, isUpper: true, quadrant: 1 }, // Midline between 8 and 9

            // Upper Left (9-16)
            9: { x: 450, y: 100, isUpper: true, quadrant: 2 },
            10: { x: 500, y: 100, isUpper: true, quadrant: 2 },
            11: { x: 550, y: 100, isUpper: true, quadrant: 2 },
            12: { x: 600, y: 100, isUpper: true, quadrant: 2 },
            13: { x: 650, y: 100, isUpper: true, quadrant: 2 },
            14: { x: 700, y: 100, isUpper: true, quadrant: 2 },
            15: { x: 750, y: 100, isUpper: true, quadrant: 2 },
            16: { x: 800, y: 100, isUpper: true, quadrant: 2 },

            // Lower Right (25-32)
            32: { x: 50, y: 300, isUpper: false, quadrant: 4 },
            31: { x: 100, y: 300, isUpper: false, quadrant: 4 },
            30: { x: 150, y: 300, isUpper: false, quadrant: 4 },
            29: { x: 200, y: 300, isUpper: false, quadrant: 4 },
            28: { x: 250, y: 300, isUpper: false, quadrant: 4 },
            27: { x: 300, y: 300, isUpper: false, quadrant: 4 },
            26: { x: 350, y: 300, isUpper: false, quadrant: 4 },
            25: { x: 400, y: 300, isUpper: false, quadrant: 4 }, // Midline between 25 and 24

            // Lower Left (17-24)
            24: { x: 450, y: 300, isUpper: false, quadrant: 3 },
            23: { x: 500, y: 300, isUpper: false, quadrant: 3 },
            22: { x: 550, y: 300, isUpper: false, quadrant: 3 },
            21: { x: 600, y: 300, isUpper: false, quadrant: 3 },
            20: { x: 650, y: 300, isUpper: false, quadrant: 3 },
            19: { x: 700, y: 300, isUpper: false, quadrant: 3 },
            18: { x: 750, y: 300, isUpper: false, quadrant: 3 },
            17: { x: 800, y: 300, isUpper: false, quadrant: 3 },
        };

        // --- Drawing the initial blank chart ---
        function createTooth(toothNum, x, y, size = 18, isUpper = true, quadrant) {
            const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
            group.setAttribute("id", `tooth-group-${toothNum}`);

            // Outer circle (overall tooth shape)
            const outerCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            outerCircle.setAttribute("cx", x);
            outerCircle.setAttribute("cy", y);
            outerCircle.setAttribute("r", size);
            outerCircle.setAttribute("class", "tooth-outline");
            group.appendChild(outerCircle);

            teethData[toothNum] = {}; // Initialize store for this tooth's surfaces

            const smallSize = size * 0.7; // Size of individual surface rects
            const offset = size * 0.6;    // Offset from center for surface rects

            // Determine if on right side (1 or 4) or left side (2 or 3) for M/D orientation
            const isRightQuadrant = (quadrant === 1 || quadrant === 4);

            // FLIPPED SIGNS FOR VISUAL 180 DEGREE ROTATION (relative to previous version)
            const mesialXOffset = isRightQuadrant ? offset : -offset;
            const distalXOffset = isRightQuadrant ? -offset : offset;

            const buccalFacialYOffset = isUpper ? -offset : offset;
            const lingualYOffset = isUpper ? offset : -offset;



            // M (Mesial)
            const M_path = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            M_path.setAttribute("x", x + mesialXOffset - smallSize / 2);
            M_path.setAttribute("y", y - smallSize / 2);
            M_path.setAttribute("width", smallSize);
            M_path.setAttribute("height", smallSize);
            M_path.setAttribute("class", "tooth-surface");
            M_path.setAttribute("id", `tooth-${toothNum}-M`);
            M_path.setAttribute("data-surface", "M");
            group.appendChild(M_path);
            teethData[toothNum]['M'] = M_path;

            // D (Distal)
            const D_path = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            D_path.setAttribute("x", x + distalXOffset - smallSize / 2);
            D_path.setAttribute("y", y - smallSize / 2);
            D_path.setAttribute("width", smallSize);
            D_path.setAttribute("height", smallSize);
            D_path.setAttribute("class", "tooth-surface");
            D_path.setAttribute("id", `tooth-${toothNum}-D`);
            D_path.setAttribute("data-surface", "D");
            group.appendChild(D_path);
            teethData[toothNum]['D'] = D_path;

            // B/F (Buccal/Facial - outer side, towards cheek/lip)
            const BF_path = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            BF_path.setAttribute("x", x - smallSize / 2);
            BF_path.setAttribute("y", y + buccalFacialYOffset - smallSize / 2);
            BF_path.setAttribute("width", smallSize);
            BF_path.setAttribute("height", smallSize);
            BF_path.setAttribute("class", "tooth-surface");
            BF_path.setAttribute("id", `tooth-${toothNum}-BF`);
            BF_path.setAttribute("data-surface", "B"); // Store as B, also acts as F
            group.appendChild(BF_path);
            teethData[toothNum]['B'] = BF_path;
            teethData[toothNum]['F'] = BF_path;

            // L (Lingual - inner side, towards tongue)
            const L_path = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            L_path.setAttribute("x", x - smallSize / 2);
            L_path.setAttribute("y", y + lingualYOffset - smallSize / 2);
            L_path.setAttribute("width", smallSize);
            L_path.setAttribute("height", smallSize);
            L_path.setAttribute("class", "tooth-surface");
            L_path.setAttribute("id", `tooth-${toothNum}-L`);
            L_path.setAttribute("data-surface", "L");
            group.appendChild(L_path);
            teethData[toothNum]['L'] = L_path;


			// O/I (Occlusal/Incisal - center)
            const OI_path = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            OI_path.setAttribute("x", x - smallSize / 2);
            OI_path.setAttribute("y", y - smallSize / 2);
            OI_path.setAttribute("width", smallSize);
            OI_path.setAttribute("height", smallSize);
            OI_path.setAttribute("class", "tooth-surface");
            OI_path.setAttribute("id", `tooth-${toothNum}-O`);
            OI_path.setAttribute("data-surface", "O");
            group.appendChild(OI_path);
            teethData[toothNum]['O'] = OI_path;
            teethData[toothNum]['I'] = OI_path; // Incisal for anterior teeth shares this path
			

            // Tooth number label
            const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
            label.setAttribute("x", x);
            label.setAttribute("y", isUpper ? y + size + 8 : y - size - 4);
            label.setAttribute("class", "tooth-label");
            label.textContent = toothNum;
            group.appendChild(label);

            return group;
        }

        function initializeChart() {
            dentalChartSVG.innerHTML = ''; // Clear previous chart

            // --- Mouth Labels and Lines ---
            // Facial Label (Upper)
            dentalChartSVG.appendChild(createLabel("Facial", 425, 30, "mouth-label"));
            dentalChartSVG.appendChild(createLine(20, 40, 780, 40, "label-line"));

            // Lingual Label (Upper)
            dentalChartSVG.appendChild(createLabel("Lingual", 425, 170, "mouth-label"));
            dentalChartSVG.appendChild(createLine(20, 180, 780, 180, "label-line"));


            // Lingual Label (Lower)
            dentalChartSVG.appendChild(createLabel("Lingual", 425, 230, "mouth-label"));
            dentalChartSVG.appendChild(createLine(20, 240, 780, 240, "label-line"));

            // Facial Label (Lower)
            dentalChartSVG.appendChild(createLabel("Facial", 425, 370, "mouth-label"));
            dentalChartSVG.appendChild(createLine(20, 380, 780, 380, "label-line"));


            // --- Arch Lines (simplified path) ---
            const upperArchLine = document.createElementNS("http://www.w3.org/2000/svg", "path");
            upperArchLine.setAttribute("d", "M 20 120 C 200 60, 600 60, 830 120");
            upperArchLine.setAttribute("class", "arch-line");
            dentalChartSVG.appendChild(upperArchLine);

            const lowerArchLine = document.createElementNS("http://www.w3.org/2000/svg", "path");
            lowerArchLine.setAttribute("d", "M 20 280 C 200 340, 600 340, 830 280");
            lowerArchLine.setAttribute("class", "arch-line");
            dentalChartSVG.appendChild(lowerArchLine);

            // --- Tooth Elements ---
            // Upper teeth (1-16)
            for (let i = 1; i <= 16; i++) {
                const pos = toothPositions[i];
                if (pos) {
                    dentalChartSVG.appendChild(createTooth(i, pos.x, pos.y, 18, pos.isUpper, pos.quadrant));
                }
            }

            // Lower teeth (17-32) - drawing 32 down to 17 for left-to-right display
            for (let i = 32; i >= 17; i--) {
                const pos = toothPositions[i];
                if (pos) {
                    dentalChartSVG.appendChild(createTooth(i, pos.x, pos.y, 18, pos.isUpper, pos.quadrant));
                }
            }

            // Reset all surfaces to default color before marking
            document.querySelectorAll('.tooth-surface').forEach(path => {
                path.classList.remove('caries');
            });
        }

        function createLabel(text, x, y, className) {
            const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
            label.setAttribute("x", x);
            label.setAttribute("y", y);
            label.setAttribute("class", className);
            label.textContent = text;
            return label;
        }

        function createLine(x1, y1, x2, y2, className) {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", x1);
            line.setAttribute("y1", y1);
            line.setAttribute("x2", x2);
            line.setAttribute("y2", y2);
            line.setAttribute("class", className);
            return line;
        }


        // --- Parsing and Charting Logic ---
        const OPERATIVE_KEYWORD = "CHARTING OF TREATMENT PLAN IN DENTRIX";

        function parsePrompt(fullPrompt) {
            let relevantPrompt = fullPrompt.trim();
            const keywordIndex = relevantPrompt.toUpperCase().indexOf(OPERATIVE_KEYWORD);

            if (keywordIndex !== -1) {
                // Take text after the keyword
                relevantPrompt = relevantPrompt.substring(keywordIndex + OPERATIVE_KEYWORD.length).trim();
            }
            // If keyword not found, the fullPrompt (trimmed) is used.

            const cariesData = [];
            const regex = /(\d+)\s*\(([^)]+)\)/g;
            let match;
            while ((match = regex.exec(relevantPrompt)) !== null) { // Use relevantPrompt here
                const toothNum = parseInt(match[1]);
                const surfaceStr = match[2].toUpperCase();

                const surfaces = new Set();

                // First, check for common compound abbreviations
                if (surfaceStr.includes('MOD')) {
                    surfaces.add('M'); surfaces.add('O'); surfaces.add('D');
                } else if (surfaceStr.includes('MO')) {
                    surfaces.add('M'); surfaces.add('O');
                } else if (surfaceStr.includes('DO')) {
                    surfaces.add('D'); surfaces.add('O');
                } else if (surfaceStr.includes('MI')) {
                    surfaces.add('M'); surfaces.add('I');
                } else if (surfaceStr.includes('DI')) {
                    surfaces.add('D'); surfaces.add('I');
                }

                // Then, iterate through the string to catch individual surfaces,
                // including those that might be part of or combined with compounds (e.g., MODFL)
                for (let i = 0; i < surfaceStr.length; i++) {
                    const s = surfaceStr[i];
                    if (['M', 'O', 'D', 'I', 'B', 'F', 'L'].includes(s)) {
                        surfaces.add(s);
                    }
                }
                cariesData.push({ toothNum, surfaces: Array.from(surfaces) });
            }
            return cariesData;
        }

        function markCaries(cariesInfo) {
            cariesInfo.forEach(item => {
                const toothNum = item.toothNum;
                item.surfaces.forEach(surface => {
                    const surfacePath = teethData[toothNum] && teethData[toothNum][surface];
                    if (surfacePath) {
                        surfacePath.classList.add('caries');
                    } else {
                        console.warn(`Could not find SVG element for tooth ${toothNum}, surface ${surface}. This might be an invalid surface or a drawing error.`);
                        const centralSurface = teethData[toothNum] && (teethData[toothNum]['O'] || teethData[toothNum]['I']);
                        if (centralSurface) {
                            centralSurface.classList.add('caries');
                        }
                    }
                });
            });
        }

        function generateChart() {
            initializeChart();
            const prompt = document.getElementById('live-output').value;
            const cariesToMark = parsePrompt(prompt);
            markCaries(cariesToMark);
        }





</script>










</body>
</html>
